"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformStack = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const constructs_1 = require("constructs");
const _tokens_1 = require("./_tokens");
const terraform_element_1 = require("./terraform-element");
const util_1 = require("./util");
const terraform_provider_1 = require("./terraform-provider");
const local_backend_1 = require("./backends/local-backend");
const tfExpression_1 = require("./tfExpression");
const terraform_output_1 = require("./terraform-output");
const unique_1 = require("./private/unique");
const synthesizer_1 = require("./synthesize/synthesizer");
const STACK_SYMBOL = Symbol.for("cdktf/TerraformStack");
const validations_1 = require("./validations");
const app_1 = require("./app");
const terraform_backend_1 = require("./terraform-backend");
// eslint-disable-next-line jsdoc/require-jsdoc
function throwIfIdIsGlobCharacter(str) {
    const err = (char) => `Can not create Terraform stack with id "${str}". It contains a glob character: "${char}"`;
    ["*", "?", "[", "]", "{", "}", "!"].forEach((char) => {
        if (str.includes(char)) {
            throw new Error(err(char));
        }
    });
}
// eslint-disable-next-line jsdoc/require-jsdoc
function throwIfIdContainsWhitespace(str) {
    if (/\s/.test(str)) {
        throw new Error(`Can not create TerraformStack with id "${str}". It contains a whitespace character.`);
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
class TerraformStack extends constructs_1.Construct {
    constructor(scope, id) {
        super(scope, id);
        this.rawOverrides = {};
        this.crossStackOutputs = {};
        this.crossStackDataSources = {};
        this.dependencies = [];
        throwIfIdIsGlobCharacter(id);
        throwIfIdContainsWhitespace(id);
        this.cdktfVersion = this.node.tryGetContext("cdktfVersion");
        this.synthesizer = new synthesizer_1.StackSynthesizer(this, process.env.CDKTF_CONTINUE_SYNTH_ON_ERROR_ANNOTATIONS !== undefined);
        Object.defineProperty(this, STACK_SYMBOL, { value: true });
        this.node.addValidation(new validations_1.ValidateProviderPresence(this));
    }
    static isStack(x) {
        return x !== null && typeof x === "object" && STACK_SYMBOL in x;
    }
    static of(construct) {
        return _lookup(construct);
        // eslint-disable-next-line jsdoc/require-jsdoc
        function _lookup(c) {
            if (TerraformStack.isStack(c)) {
                return c;
            }
            const node = c.node;
            if (!node.scope) {
                let hint = "";
                if (construct.node.scope === c &&
                    app_1.App.isApp(c) &&
                    terraform_backend_1.TerraformBackend.isBackend(construct)) {
                    // the scope of the originally passed construct equals the construct c
                    // which has no scope (i.e. has no parent construct) and c is an App
                    // and our construct is a Backend
                    hint = `. You seem to have passed your root App as scope to a TerraformBackend construct. Pass a stack as scope to your backend instead.`;
                }
                throw new Error(`No stack could be identified for the construct at path '${construct.node.path}'${hint}`);
            }
            return _lookup(node.scope);
        }
    }
    findAll(predicate) {
        const items = [];
        const visit = async (node) => {
            if (predicate(node)) {
                items.push(node);
            }
            for (const child of node.node.children) {
                visit(child);
            }
        };
        visit(this);
        return items;
    }
    prepareStack() {
        // Ensure we have a backend configured
        this.ensureBackendExists();
        // A preparing resolve run might add new resources to the stack, e.g. for cross stack references.
        terraformElements(this).forEach((e) => (0, _tokens_1.resolve)(this, e.toTerraform(), true));
    }
    addOverride(path, value) {
        const parts = path.split(".");
        let curr = this.rawOverrides;
        while (parts.length > 1) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const key = parts.shift();
            // if we can't recurse further or the previous value is not an
            // object overwrite it with an object.
            const isObject = curr[key] != null &&
                typeof curr[key] === "object" &&
                !Array.isArray(curr[key]);
            if (!isObject) {
                curr[key] = {};
            }
            curr = curr[key];
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lastKey = parts.shift();
        curr[lastKey] = value;
    }
    getLogicalId(tfElement) {
        // wrap the allocation for future renaming support
        return this.allocateLogicalId(tfElement);
    }
    /**
     * Returns the naming scheme used to allocate logical IDs. By default, uses
     * the `HashedAddressingScheme` but this method can be overridden to customize
     * this behavior.
     *
     * @param tfElement The element for which the logical ID is allocated.
     */
    allocateLogicalId(tfElement) {
        const node = terraform_element_1.TerraformElement.isTerraformElement(tfElement)
            ? tfElement.node
            : tfElement;
        const stack = terraform_element_1.TerraformElement.isTerraformElement(tfElement)
            ? tfElement.cdktfStack
            : this;
        const stackIndex = node.scopes.indexOf(stack);
        const components = node.scopes.slice(stackIndex + 1).map((c) => c.node.id);
        return components.length > 0 ? (0, unique_1.makeUniqueId)(components) : "";
    }
    allProviders() {
        return this.findAll(terraform_provider_1.TerraformProvider.isTerraformProvider);
    }
    ensureBackendExists() {
        const backends = this.findAll(terraform_backend_1.TerraformBackend.isBackend);
        return backends[0] || new local_backend_1.LocalBackend(this, {});
    }
    toTerraform() {
        const tf = {};
        const metadata = {
            version: this.cdktfVersion,
            stackName: this.node.id,
            backend: "local",
            cloud: undefined,
            ...(Object.keys(this.rawOverrides).length > 0
                ? { overrides: { stack: Object.keys(this.rawOverrides) } }
                : {}),
        };
        const elements = terraformElements(this);
        const metadatas = elements.map((e) => (0, _tokens_1.resolve)(this, e.toMetadata()));
        for (const meta of metadatas) {
            (0, util_1.deepMerge)(metadata, meta);
        }
        const outputs = elements.reduce((carry, item) => {
            if (!terraform_output_1.TerraformOutput.isTerraformOutput(item)) {
                return carry;
            }
            (0, util_1.deepMerge)(carry, item.node.path.split("/").reduceRight((innerCarry, part) => {
                if (Object.keys(innerCarry).length === 0) {
                    return { [part]: item.friendlyUniqueId };
                }
                return { [part]: innerCarry };
            }, {}));
            return carry;
        }, {});
        tf["//"] = { metadata, outputs };
        const fragments = elements.map((e) => (0, _tokens_1.resolve)(this, e.toTerraform()));
        for (const fragment of fragments) {
            (0, util_1.deepMerge)(tf, fragment);
        }
        (0, util_1.deepMerge)(tf, this.rawOverrides);
        return (0, _tokens_1.resolve)(this, tf);
    }
    registerOutgoingCrossStackReference(identifier) {
        if (this.crossStackOutputs[identifier]) {
            return this.crossStackOutputs[identifier];
        }
        const output = new terraform_output_1.TerraformOutput(this, `cross-stack-output-${identifier}`, {
            value: (0, tfExpression_1.ref)(identifier, this),
            sensitive: true,
        });
        this.crossStackOutputs[identifier] = output;
        return output;
    }
    registerIncomingCrossStackReference(fromStack) {
        if (this.crossStackDataSources[String(fromStack)]) {
            return this.crossStackDataSources[String(fromStack)];
        }
        const originBackend = fromStack.ensureBackendExists();
        const originPath = fromStack.node.path;
        const remoteState = originBackend.getRemoteStateDataSource(this, `cross-stack-reference-input-${originPath}`, originPath);
        this.crossStackDataSources[originPath] = remoteState;
        return remoteState;
    }
    // Check here for loops in the dependency graph
    dependsOn(stack) {
        return (this.dependencies.includes(stack) ||
            this.dependencies.some((d) => d.dependsOn(stack)));
    }
    addDependency(dependency) {
        if (dependency.dependsOn(this)) {
            throw new Error(`Can not add dependency ${dependency} to ${this} since it would result in a loop`);
        }
        if (this.dependencies.includes(dependency)) {
            return;
        }
        this.dependencies.push(dependency);
    }
    /**
     * Run all validations on the stack.
     */
    runAllValidations() {
        const errors = this.node
            .findAll()
            .map((node) => node.node.validate().map((error) => ({ message: error, source: node })))
            .reduce((prev, curr) => [...prev, ...curr], []);
        if (errors.length > 0) {
            const errorList = errors
                .map((e) => `[${e.source.node.path}] ${e.message}`)
                .join("\n  ");
            throw new Error(`Validation failed with the following errors:\n  ${errorList}`);
        }
    }
}
_a = JSII_RTTI_SYMBOL_1;
TerraformStack[_a] = { fqn: "cdktf.TerraformStack", version: "0.17.3" };
exports.TerraformStack = TerraformStack;
// eslint-disable-next-line jsdoc/require-jsdoc
function terraformElements(node, into = []) {
    if (terraform_element_1.TerraformElement.isTerraformElement(node)) {
        into.push(node);
    }
    for (const child of node.node.children) {
        // Don't recurse into a substack
        if (TerraformStack.isStack(child)) {
            continue;
        }
        terraformElements(child, into);
    }
    return into;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVycmFmb3JtLXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQywyQ0FBeUQ7QUFDekQsdUNBQW9DO0FBRXBDLDJEQUF1RDtBQUN2RCxpQ0FBbUM7QUFDbkMsNkRBQXlEO0FBQ3pELDREQUF3RDtBQUN4RCxpREFBcUM7QUFDckMseURBQXFEO0FBRXJELDZDQUFnRDtBQUVoRCwwREFBNEQ7QUFFNUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ3hELCtDQUF5RDtBQUN6RCwrQkFBNEI7QUFDNUIsMkRBQXVEO0FBZXZELCtDQUErQztBQUMvQyxTQUFTLHdCQUF3QixDQUFDLEdBQVc7SUFDM0MsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRSxDQUMzQiwyQ0FBMkMsR0FBRyxxQ0FBcUMsSUFBSSxHQUFHLENBQUM7SUFFN0YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNuRCxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUM1QjtJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELCtDQUErQztBQUMvQyxTQUFTLDJCQUEyQixDQUFDLEdBQVc7SUFDOUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQ2IsMENBQTBDLEdBQUcsd0NBQXdDLENBQ3RGLENBQUM7S0FDSDtBQUNILENB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SUFFRCxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1FBQ3RDLGdDQUFnQztRQUNoQyxJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDakMsU0FBUztTQUNWO1FBRUQsaUJBQWlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ2hDO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCwgTm9kZSB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcIi4vX3Rva2Vuc1wiO1xuXG5pbXBvcnQgeyBUZXJyYWZvcm1FbGVtZW50IH0gZnJvbSBcIi4vdGVycmFmb3JtLWVsZW1lbnRcIjtcbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7IFRlcnJhZm9ybVByb3ZpZGVyIH0gZnJvbSBcIi4vdGVycmFmb3JtLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBMb2NhbEJhY2tlbmQgfSBmcm9tIFwiLi9iYWNrZW5kcy9sb2NhbC1iYWNrZW5kXCI7XG5pbXBvcnQgeyByZWYgfSBmcm9tIFwiLi90ZkV4cHJlc3Npb25cIjtcbmltcG9ydCB7IFRlcnJhZm9ybU91dHB1dCB9IGZyb20gXCIuL3RlcnJhZm9ybS1vdXRwdXRcIjtcbmltcG9ydCB7IFRlcnJhZm9ybVJlbW90ZVN0YXRlIH0gZnJvbSBcIi4vdGVycmFmb3JtLXJlbW90ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgbWFrZVVuaXF1ZUlkIH0gZnJvbSBcIi4vcHJpdmF0ZS91bmlxdWVcIjtcbmltcG9ydCB7IElTdGFja1N5bnRoZXNpemVyIH0gZnJvbSBcIi4vc3ludGhlc2l6ZS90eXBlc1wiO1xuaW1wb3J0IHsgU3RhY2tTeW50aGVzaXplciB9IGZyb20gXCIuL3N5bnRoZXNpemUvc3ludGhlc2l6ZXJcIjtcblxuY29uc3QgU1RBQ0tfU1lNQk9MID0gU3ltYm9sLmZvcihcImNka3RmL1RlcnJhZm9ybVN0YWNrXCIpO1xuaW1wb3J0IHsgVmFsaWRhdGVQcm92aWRlclByZXNlbmNlIH0gZnJvbSBcIi4vdmFsaWRhdGlvbnNcIjtcbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuL2FwcFwiO1xuaW1wb3J0IHsgVGVycmFmb3JtQmFja2VuZCB9IGZyb20gXCIuL3RlcnJhZm9ybS1iYWNrZW5kXCI7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG50eXBlIFN0YWNrSWRlbnRpZmllciA9IHN0cmluZztcbnR5cGUgT3V0cHV0SWRNYXAgPVxuICB8IHsgW2NvbnN0cnVjdElkOiBzdHJpbmddOiBzdHJpbmcgfVxuICB8IHsgW3N0YWNrT3JDb25zdHJ1Y3RJZDogc3RyaW5nXTogT3V0cHV0SWRNYXAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBUZXJyYWZvcm1TdGFja01ldGFkYXRhIHtcbiAgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYmFja2VuZDogc3RyaW5nO1xuICByZWFkb25seSBjbG91ZD86IHN0cmluZztcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIHRocm93SWZJZElzR2xvYkNoYXJhY3RlcihzdHI6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBlcnIgPSAoY2hhcjogc3RyaW5nKSA9PlxuICAgIGBDYW4gbm90IGNyZWF0ZSBUZXJyYWZvcm0gc3RhY2sgd2l0aCBpZCBcIiR7c3RyfVwiLiBJdCBjb250YWlucyBhIGdsb2IgY2hhcmFjdGVyOiBcIiR7Y2hhcn1cImA7XG5cbiAgW1wiKlwiLCBcIj9cIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIFwiIVwiXS5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgaWYgKHN0ci5pbmNsdWRlcyhjaGFyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycihjaGFyKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIHRocm93SWZJZENvbnRhaW5zV2hpdGVzcGFjZShzdHI6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoL1xccy8udGVzdChzdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgY3JlYXRlIFRlcnJhZm9ybVN0YWNrIHdpdGggaWQgXCIke3N0cn1cIi4gSXQgY29udGFpbnMgYSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGNsYXNzIFRlcnJhZm9ybVN0YWNrIGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgcHJpdmF0ZSByZWFkb25seSByYXdPdmVycmlkZXM6IGFueSA9IHt9O1xuICBwcml2YXRlIHJlYWRvbmx5IGNka3RmVmVyc2lvbjogc3RyaW5nO1xuICBwcml2YXRlIGNyb3NzU3RhY2tPdXRwdXRzOiBSZWNvcmQ8U3RhY2tJZGVudGlmaWVyLCBUZXJyYWZvcm1PdXRwdXQ+ID0ge307XG4gIHByaXZhdGUgY3Jvc3NTdGFja0RhdGFTb3VyY2VzOiBSZWNvcmQ8U3RhY2tJZGVudGlmaWVyLCBUZXJyYWZvcm1SZW1vdGVTdGF0ZT4gPVxuICAgIHt9O1xuICBwdWJsaWMgc3ludGhlc2l6ZXI6IElTdGFja1N5bnRoZXNpemVyO1xuICBwdWJsaWMgZGVwZW5kZW5jaWVzOiBUZXJyYWZvcm1TdGFja1tdID0gW107XG5cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICB0aHJvd0lmSWRJc0dsb2JDaGFyYWN0ZXIoaWQpO1xuICAgIHRocm93SWZJZENvbnRhaW5zV2hpdGVzcGFjZShpZCk7XG4gICAgdGhpcy5jZGt0ZlZlcnNpb24gPSB0aGlzLm5vZGUudHJ5R2V0Q29udGV4dChcImNka3RmVmVyc2lvblwiKTtcbiAgICB0aGlzLnN5bnRoZXNpemVyID0gbmV3IFN0YWNrU3ludGhlc2l6ZXIoXG4gICAgICB0aGlzLFxuICAgICAgcHJvY2Vzcy5lbnYuQ0RLVEZfQ09OVElOVUVfU1lOVEhfT05fRVJST1JfQU5OT1RBVElPTlMgIT09IHVuZGVmaW5lZFxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNUQUNLX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB0aGlzLm5vZGUuYWRkVmFsaWRhdGlvbihuZXcgVmFsaWRhdGVQcm92aWRlclByZXNlbmNlKHRoaXMpKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXNTdGFjayh4OiBhbnkpOiB4IGlzIFRlcnJhZm9ybVN0YWNrIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBTVEFDS19TWU1CT0wgaW4geDtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgb2YoY29uc3RydWN0OiBJQ29uc3RydWN0KTogVGVycmFmb3JtU3RhY2sge1xuICAgIHJldHVybiBfbG9va3VwKGNvbnN0cnVjdCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuICAgIGZ1bmN0aW9uIF9sb29rdXAoYzogSUNvbnN0cnVjdCk6IFRlcnJhZm9ybVN0YWNrIHtcbiAgICAgIGlmIChUZXJyYWZvcm1TdGFjay5pc1N0YWNrKGMpKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gYy5ub2RlO1xuXG4gICAgICBpZiAoIW5vZGUuc2NvcGUpIHtcbiAgICAgICAgbGV0IGhpbnQgPSBcIlwiO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY29uc3RydWN0Lm5vZGUuc2NvcGUgPT09IGMgJiZcbiAgICAgICAgICBBcHAuaXNBcHAoYykgJiZcbiAgICAgICAgICBUZXJyYWZvcm1CYWNrZW5kLmlzQmFja2VuZChjb25zdHJ1Y3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHRoZSBzY29wZSBvZiB0aGUgb3JpZ2luYWxseSBwYXNzZWQgY29uc3RydWN0IGVxdWFscyB0aGUgY29uc3RydWN0IGNcbiAgICAgICAgICAvLyB3aGljaCBoYXMgbm8gc2NvcGUgKGkuZS4gaGFzIG5vIHBhcmVudCBjb25zdHJ1Y3QpIGFuZCBjIGlzIGFuIEFwcFxuICAgICAgICAgIC8vIGFuZCBvdXIgY29uc3RydWN0IGlzIGEgQmFja2VuZFxuICAgICAgICAgIGhpbnQgPSBgLiBZb3Ugc2VlbSB0byBoYXZlIHBhc3NlZCB5b3VyIHJvb3QgQXBwIGFzIHNjb3BlIHRvIGEgVGVycmFmb3JtQmFja2VuZCBjb25zdHJ1Y3QuIFBhc3MgYSBzdGFjayBhcyBzY29wZSB0byB5b3VyIGJhY2tlbmQgaW5zdGVhZC5gO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBObyBzdGFjayBjb3VsZCBiZSBpZGVudGlmaWVkIGZvciB0aGUgY29uc3RydWN0IGF0IHBhdGggJyR7Y29uc3RydWN0Lm5vZGUucGF0aH0nJHtoaW50fWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9sb29rdXAobm9kZS5zY29wZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kQWxsPFQgZXh0ZW5kcyBJQ29uc3RydWN0PihcbiAgICBwcmVkaWNhdGU6IChub2RlOiB1bmtub3duKSA9PiBub2RlIGlzIFRcbiAgKTogVFtdIHtcbiAgICBjb25zdCBpdGVtczogVFtdID0gW107XG5cbiAgICBjb25zdCB2aXNpdCA9IGFzeW5jIChub2RlOiBJQ29uc3RydWN0KSA9PiB7XG4gICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5ub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmlzaXQodGhpcyk7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBwdWJsaWMgcHJlcGFyZVN0YWNrKCkge1xuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgYmFja2VuZCBjb25maWd1cmVkXG4gICAgdGhpcy5lbnN1cmVCYWNrZW5kRXhpc3RzKCk7XG4gICAgLy8gQSBwcmVwYXJpbmcgcmVzb2x2ZSBydW4gbWlnaHQgYWRkIG5ldyByZXNvdXJjZXMgdG8gdGhlIHN0YWNrLCBlLmcuIGZvciBjcm9zcyBzdGFjayByZWZlcmVuY2VzLlxuICAgIHRlcnJhZm9ybUVsZW1lbnRzKHRoaXMpLmZvckVhY2goKGUpID0+XG4gICAgICByZXNvbHZlKHRoaXMsIGUudG9UZXJyYWZvcm0oKSwgdHJ1ZSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFkZE92ZXJyaWRlKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgbGV0IGN1cnI6IGFueSA9IHRoaXMucmF3T3ZlcnJpZGVzO1xuXG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpITtcblxuICAgICAgLy8gaWYgd2UgY2FuJ3QgcmVjdXJzZSBmdXJ0aGVyIG9yIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBub3QgYW5cbiAgICAgIC8vIG9iamVjdCBvdmVyd3JpdGUgaXQgd2l0aCBhbiBvYmplY3QuXG4gICAgICBjb25zdCBpc09iamVjdCA9XG4gICAgICAgIGN1cnJba2V5XSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjdXJyW2tleV0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoY3VycltrZXldKTtcbiAgICAgIGlmICghaXNPYmplY3QpIHtcbiAgICAgICAgY3VycltrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGN1cnIgPSBjdXJyW2tleV07XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjb25zdCBsYXN0S2V5ID0gcGFydHMuc2hpZnQoKSE7XG4gICAgY3VycltsYXN0S2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGdldExvZ2ljYWxJZCh0ZkVsZW1lbnQ6IFRlcnJhZm9ybUVsZW1lbnQgfCBOb2RlKTogc3RyaW5nIHtcbiAgICAvLyB3cmFwIHRoZSBhbGxvY2F0aW9uIGZvciBmdXR1cmUgcmVuYW1pbmcgc3VwcG9ydFxuICAgIHJldHVybiB0aGlzLmFsbG9jYXRlTG9naWNhbElkKHRmRWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtaW5nIHNjaGVtZSB1c2VkIHRvIGFsbG9jYXRlIGxvZ2ljYWwgSURzLiBCeSBkZWZhdWx0LCB1c2VzXG4gICAqIHRoZSBgSGFzaGVkQWRkcmVzc2luZ1NjaGVtZWAgYnV0IHRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIGN1c3RvbWl6ZVxuICAgKiB0aGlzIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcGFyYW0gdGZFbGVtZW50IFRoZSBlbGVtZW50IGZvciB3aGljaCB0aGUgbG9naWNhbCBJRCBpcyBhbGxvY2F0ZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWxsb2NhdGVMb2dpY2FsSWQodGZFbGVtZW50OiBUZXJyYWZvcm1FbGVtZW50IHwgTm9kZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgbm9kZSA9IFRlcnJhZm9ybUVsZW1lbnQuaXNUZXJyYWZvcm1FbGVtZW50KHRmRWxlbWVudClcbiAgICAgID8gdGZFbGVtZW50Lm5vZGVcbiAgICAgIDogdGZFbGVtZW50O1xuICAgIGNvbnN0IHN0YWNrID0gVGVycmFmb3JtRWxlbWVudC5pc1RlcnJhZm9ybUVsZW1lbnQodGZFbGVtZW50KVxuICAgICAgPyB0ZkVsZW1lbnQuY2RrdGZTdGFja1xuICAgICAgOiB0aGlzO1xuXG4gICAgY29uc3Qgc3RhY2tJbmRleCA9IG5vZGUuc2NvcGVzLmluZGV4T2Yoc3RhY2spO1xuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5vZGUuc2NvcGVzLnNsaWNlKHN0YWNrSW5kZXggKyAxKS5tYXAoKGMpID0+IGMubm9kZS5pZCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHMubGVuZ3RoID4gMCA/IG1ha2VVbmlxdWVJZChjb21wb25lbnRzKSA6IFwiXCI7XG4gIH1cblxuICBwdWJsaWMgYWxsUHJvdmlkZXJzKCk6IFRlcnJhZm9ybVByb3ZpZGVyW10ge1xuICAgIHJldHVybiB0aGlzLmZpbmRBbGwoVGVycmFmb3JtUHJvdmlkZXIuaXNUZXJyYWZvcm1Qcm92aWRlcik7XG4gIH1cblxuICBwdWJsaWMgZW5zdXJlQmFja2VuZEV4aXN0cygpOiBUZXJyYWZvcm1CYWNrZW5kIHtcbiAgICBjb25zdCBiYWNrZW5kcyA9IHRoaXMuZmluZEFsbChUZXJyYWZvcm1CYWNrZW5kLmlzQmFja2VuZCk7XG4gICAgcmV0dXJuIGJhY2tlbmRzWzBdIHx8IG5ldyBMb2NhbEJhY2tlbmQodGhpcywge30pO1xuICB9XG5cbiAgcHVibGljIHRvVGVycmFmb3JtKCk6IGFueSB7XG4gICAgY29uc3QgdGYgPSB7fTtcblxuICAgIGNvbnN0IG1ldGFkYXRhOiBUZXJyYWZvcm1TdGFja01ldGFkYXRhID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5jZGt0ZlZlcnNpb24sXG4gICAgICBzdGFja05hbWU6IHRoaXMubm9kZS5pZCxcbiAgICAgIGJhY2tlbmQ6IFwibG9jYWxcIiwgLy8gb3ZlcndyaXR0ZW4gYnkgYmFja2VuZCBpbXBsZW1lbnRhdGlvbnMgaWYgdXNlZFxuICAgICAgY2xvdWQ6IHVuZGVmaW5lZCwgLy8gb3ZlcndyaXR0ZW4gYnkgY2xvdWQgYW5kIHJlbW90ZSBiYWNrZW5kIGltcGxlbWVudGF0aW9uc1xuICAgICAgLi4uKE9iamVjdC5rZXlzKHRoaXMucmF3T3ZlcnJpZGVzKS5sZW5ndGggPiAwXG4gICAgICAgID8geyBvdmVycmlkZXM6IHsgc3RhY2s6IE9iamVjdC5rZXlzKHRoaXMucmF3T3ZlcnJpZGVzKSB9IH1cbiAgICAgICAgOiB7fSksXG4gICAgfTtcblxuICAgIGNvbnN0IGVsZW1lbnRzID0gdGVycmFmb3JtRWxlbWVudHModGhpcyk7XG5cbiAgICBjb25zdCBtZXRhZGF0YXMgPSBlbGVtZW50cy5tYXAoKGUpID0+IHJlc29sdmUodGhpcywgZS50b01ldGFkYXRhKCkpKTtcbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YWRhdGFzKSB7XG4gICAgICBkZWVwTWVyZ2UobWV0YWRhdGEsIG1ldGEpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dHM6IE91dHB1dElkTWFwID0gZWxlbWVudHMucmVkdWNlKChjYXJyeSwgaXRlbSkgPT4ge1xuICAgICAgaWYgKCFUZXJyYWZvcm1PdXRwdXQuaXNUZXJyYWZvcm1PdXRwdXQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgICAgfVxuXG4gICAgICBkZWVwTWVyZ2UoXG4gICAgICAgIGNhcnJ5LFxuICAgICAgICBpdGVtLm5vZGUucGF0aC5zcGxpdChcIi9cIikucmVkdWNlUmlnaHQoKGlubmVyQ2FycnksIHBhcnQpID0+IHtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoaW5uZXJDYXJyeSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBbcGFydF06IGl0ZW0uZnJpZW5kbHlVbmlxdWVJZCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBbcGFydF06IGlubmVyQ2FycnkgfTtcbiAgICAgICAgfSwge30pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY2Fycnk7XG4gICAgfSwge30pO1xuXG4gICAgKHRmIGFzIGFueSlbXCIvL1wiXSA9IHsgbWV0YWRhdGEsIG91dHB1dHMgfTtcblxuICAgIGNvbnN0IGZyYWdtZW50cyA9IGVsZW1lbnRzLm1hcCgoZSkgPT4gcmVzb2x2ZSh0aGlzLCBlLnRvVGVycmFmb3JtKCkpKTtcbiAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIGZyYWdtZW50cykge1xuICAgICAgZGVlcE1lcmdlKHRmLCBmcmFnbWVudCk7XG4gICAgfVxuXG4gICAgZGVlcE1lcmdlKHRmLCB0aGlzLnJhd092ZXJyaWRlcyk7XG5cbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLCB0Zik7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJPdXRnb2luZ0Nyb3NzU3RhY2tSZWZlcmVuY2UoaWRlbnRpZmllcjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuY3Jvc3NTdGFja091dHB1dHNbaWRlbnRpZmllcl0pIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3NzU3RhY2tPdXRwdXRzW2lkZW50aWZpZXJdO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBUZXJyYWZvcm1PdXRwdXQoXG4gICAgICB0aGlzLFxuICAgICAgYGNyb3NzLXN0YWNrLW91dHB1dC0ke2lkZW50aWZpZXJ9YCxcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHJlZihpZGVudGlmaWVyLCB0aGlzKSxcbiAgICAgICAgc2Vuc2l0aXZlOiB0cnVlLFxuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLmNyb3NzU3RhY2tPdXRwdXRzW2lkZW50aWZpZXJdID0gb3V0cHV0O1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJJbmNvbWluZ0Nyb3NzU3RhY2tSZWZlcmVuY2UoZnJvbVN0YWNrOiBUZXJyYWZvcm1TdGFjaykge1xuICAgIGlmICh0aGlzLmNyb3NzU3RhY2tEYXRhU291cmNlc1tTdHJpbmcoZnJvbVN0YWNrKV0pIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3NzU3RhY2tEYXRhU291cmNlc1tTdHJpbmcoZnJvbVN0YWNrKV07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbkJhY2tlbmQgPSBmcm9tU3RhY2suZW5zdXJlQmFja2VuZEV4aXN0cygpO1xuICAgIGNvbnN0IG9yaWdpblBhdGggPSBmcm9tU3RhY2subm9kZS5wYXRoO1xuXG4gICAgY29uc3QgcmVtb3RlU3RhdGUgPSBvcmlnaW5CYWNrZW5kLmdldFJlbW90ZVN0YXRlRGF0YVNvdXJjZShcbiAgICAgIHRoaXMsXG4gICAgICBgY3Jvc3Mtc3RhY2stcmVmZXJlbmNlLWlucHV0LSR7b3JpZ2luUGF0aH1gLFxuICAgICAgb3JpZ2luUGF0aFxuICAgICk7XG5cbiAgICB0aGlzLmNyb3NzU3RhY2tEYXRhU291cmNlc1tvcmlnaW5QYXRoXSA9IHJlbW90ZVN0YXRlO1xuICAgIHJldHVybiByZW1vdGVTdGF0ZTtcbiAgfVxuXG4gIC8vIENoZWNrIGhlcmUgZm9yIGxvb3BzIGluIHRoZSBkZXBlbmRlbmN5IGdyYXBoXG4gIHB1YmxpYyBkZXBlbmRzT24oc3RhY2s6IFRlcnJhZm9ybVN0YWNrKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHN0YWNrKSB8fFxuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuc29tZSgoZCkgPT4gZC5kZXBlbmRzT24oc3RhY2spKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYWRkRGVwZW5kZW5jeShkZXBlbmRlbmN5OiBUZXJyYWZvcm1TdGFjaykge1xuICAgIGlmIChkZXBlbmRlbmN5LmRlcGVuZHNPbih0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2FuIG5vdCBhZGQgZGVwZW5kZW5jeSAke2RlcGVuZGVuY3l9IHRvICR7dGhpc30gc2luY2UgaXQgd291bGQgcmVzdWx0IGluIGEgbG9vcGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmluY2x1ZGVzKGRlcGVuZGVuY3kpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZXBlbmRlbmNpZXMucHVzaChkZXBlbmRlbmN5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gYWxsIHZhbGlkYXRpb25zIG9uIHRoZSBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBydW5BbGxWYWxpZGF0aW9ucygpIHtcbiAgICBjb25zdCBlcnJvcnM6IHsgbWVzc2FnZTogc3RyaW5nOyBzb3VyY2U6IElDb25zdHJ1Y3QgfVtdID0gdGhpcy5ub2RlXG4gICAgICAuZmluZEFsbCgpXG4gICAgICAubWFwKChub2RlKSA9PlxuICAgICAgICBub2RlLm5vZGUudmFsaWRhdGUoKS5tYXAoKGVycm9yKSA9PiAoeyBtZXNzYWdlOiBlcnJvciwgc291cmNlOiBub2RlIH0pKVxuICAgICAgKVxuICAgICAgLnJlZHVjZSgocHJldiwgY3VycikgPT4gWy4uLnByZXYsIC4uLmN1cnJdLCBbXSk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBlcnJvckxpc3QgPSBlcnJvcnNcbiAgICAgICAgLm1hcCgoZSkgPT4gYFske2Uuc291cmNlLm5vZGUucGF0aH1dICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIC5qb2luKFwiXFxuICBcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBWYWxpZGF0aW9uIGZhaWxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3JzOlxcbiAgJHtlcnJvckxpc3R9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIHRlcnJhZm9ybUVsZW1lbnRzKFxuICBub2RlOiBJQ29uc3RydWN0LFxuICBpbnRvOiBUZXJyYWZvcm1FbGVtZW50W10gPSBbXVxuKTogVGVycmFmb3JtRWxlbWVudFtdIHtcbiAgaWYgKFRlcnJhZm9ybUVsZW1lbnQuaXNUZXJyYWZvcm1FbGVtZW50KG5vZGUpKSB7XG4gICAgaW50by5wdXNoKG5vZGUpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLm5vZGUuY2hpbGRyZW4pIHtcbiAgICAvLyBEb24ndCByZWN1cnNlIGludG8gYSBzdWJzdGFja1xuICAgIGlmIChUZXJyYWZvcm1TdGFjay5pc1N0YWNrKGNoaWxkKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdGVycmFmb3JtRWxlbWVudHMoY2hpbGQsIGludG8pO1xuICB9XG5cbiAgcmV0dXJuIGludG87XG59XG4iXX0=