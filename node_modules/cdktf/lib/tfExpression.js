"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dependable = exports.forExpression = exports.FOR_EXPRESSION_VALUE = exports.FOR_EXPRESSION_KEY = exports.call = exports.OperatorExpression = exports.conditional = exports.propertyAccess = exports.insideTfExpression = exports.ref = exports.rawString = void 0;
const intrinsic_1 = require("./tokens/private/intrinsic");
const token_1 = require("./tokens/token");
const _1 = require(".");
const terraform_stack_1 = require("./terraform-stack");
const constructs_1 = require("constructs");
const TERRAFORM_IDENTIFIER_REGEX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
// eslint-disable-next-line jsdoc/require-jsdoc
class TFExpression extends intrinsic_1.Intrinsic {
    resolveArg(context, arg) {
        const resolvedArg = context.resolve(arg);
        if (token_1.Tokenization.isResolvable(arg)) {
            return resolvedArg;
        }
        if (typeof arg === "string") {
            return this.resolveString(arg, resolvedArg);
        }
        if (Array.isArray(resolvedArg)) {
            return `[${resolvedArg
                .map((_, index) => this.resolveArg(context, arg[index]))
                .join(", ")}]`;
        }
        if (typeof resolvedArg === "object" && resolvedArg !== null) {
            return `{${Object.keys(resolvedArg)
                .map((key) => `"${key}" = ${this.resolveArg(context, arg[key])}`)
                .join(", ")}}`;
        }
        return resolvedArg;
    }
    /**
     * Escape string removes characters from the string that are not allowed in Terraform or JSON
     * It must only be used on non-token values
     */
    escapeString(str) {
        return str
            .replace(/\n/g, "\\n") // escape newlines
            .replace(/\${/g, "$$${"); // escape ${ to $${
    }
    resolveString(str, resolvedArg) {
        const tokenList = token_1.Tokenization.reverseString(str);
        const numberOfTokens = tokenList.tokens.length + tokenList.intrinsic.length;
        // String literal
        if (numberOfTokens === 0) {
            return resolvedArg !== `"` &&
                resolvedArg.startsWith('"') &&
                resolvedArg.endsWith('"')
                ? this.escapeString(resolvedArg)
                : `"${this.escapeString(resolvedArg)}"`;
        }
        // Only a token reference
        if (tokenList.literals.length === 0 &&
            tokenList.escapes.length === 0 &&
            numberOfTokens === 1) {
            return resolvedArg;
        }
        // String literal + token reference combination
        const joinResult = tokenList.join({
            join: (left, right) => {
                const leftTokens = token_1.Tokenization.reverse(left);
                const leftTokenList = token_1.Tokenization.reverseString(left);
                const rightTokens = token_1.Tokenization.reverse(right);
                const leftTokenCount = leftTokenList.intrinsic.length + leftTokenList.tokens.length;
                // if left is mixed, needs to be left alone (because it's a result of a previous join iteration)
                let leftValue = left;
                // if left is a string literal, then we need to escape it
                if (leftTokenList.literals.length === 1 && leftTokenCount === 0) {
                    leftValue = this.escapeString(left);
                }
                // if left is only a token, needs to be wrapped as terraform expression
                if (leftTokenList.literals.length === 0 && leftTokenCount === 1) {
                    leftValue = `\${${leftTokens[0]}}`;
                }
                const rightValue = rightTokens.length === 0
                    ? this.escapeString(right)
                    : `\${${rightTokens[0]}}`;
                return `${leftValue}${rightValue}`;
            },
        });
        return joinResult !== `"` &&
            joinResult.startsWith('"') &&
            joinResult.endsWith('"')
            ? joinResult
            : `"${joinResult}"`;
    }
}
// A string that represents an input value to be escaped
// eslint-disable-next-line jsdoc/require-jsdoc
class RawString extends TFExpression {
    constructor(str) {
        super(str);
        this.str = str;
    }
    resolve(context) {
        const qts = context.suppressBraces ? `"` : ``;
        return `${qts}${this.escapeString(this.str).replace(/\"/g, '\\"')}${qts}`; // eslint-disable-line no-useless-escape
    }
    toString() {
        return this.str;
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function rawString(str) {
    return new RawString(str);
}
exports.rawString = rawString;
// eslint-disable-next-line jsdoc/require-jsdoc
class Reference extends TFExpression {
    constructor(identifier, originStack) {
        super(identifier);
        this.identifier = identifier;
        this.originStack = originStack;
        /**
         * A single reference could be used in multiple stacks,
         * e.g. if we expose the ref directly or as token on the stack.
         * We need to store the identifier for each stack,
         * so that the resolved identifier string matches the stack it's resolved in.
         */
        this.crossStackIdentifier = {};
    }
    resolve(context) {
        // We check for cross stack references on preparation, setting a new identifier
        const resolutionStack = terraform_stack_1.TerraformStack.of(context.scope);
        const stackName = resolutionStack.toString();
        const suppressBraces = context.suppressBraces;
        context.suppressBraces = true;
        if (context.preparing) {
            // Cross stack reference
            if (this.originStack && this.originStack !== resolutionStack) {
                const app = _1.App.of(this.originStack);
                const csr = app.crossStackReference(this.originStack, resolutionStack, this.identifier);
                this.crossStackIdentifier[stackName] = csr;
            }
        }
        // If this is a cross stack reference we will resolve to a reference within this stack.
        if (this.crossStackIdentifier[stackName]) {
            return suppressBraces
                ? this.crossStackIdentifier[stackName]
                : `\${${this.crossStackIdentifier[stackName]}}`;
        }
        return suppressBraces ? this.identifier : `\${${this.identifier}}`;
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function ref(identifier, stack) {
    return new Reference(identifier, stack);
}
exports.ref = ref;
/**
 * marks the argument as being used in a terraform expression
 * @deprecated
 */
function insideTfExpression(arg) {
    return arg;
}
exports.insideTfExpression = insideTfExpression;
// eslint-disable-next-line jsdoc/require-jsdoc
class PropertyAccess extends TFExpression {
    constructor(target, args) {
        super({ target, args });
        this.target = target;
        this.args = args;
    }
    resolve(context) {
        const suppressBraces = context.suppressBraces;
        context.suppressBraces = true;
        const serializedArgs = this.args
            .map((arg) => {
            if (arg === `*`) {
                return "[*]";
            }
            const a = this.resolveArg(context, arg);
            const isPlainString = typeof arg === "string" && TERRAFORM_IDENTIFIER_REGEX.test(arg);
            const isPlainNumber = typeof arg === "number" && !token_1.Token.isUnresolved(arg);
            if (isPlainString || isPlainNumber) {
                return `.${arg}`;
            }
            return `[${a}]`;
        }) // property access
            .join("");
        const targetExpr = constructs_1.Construct.isConstruct(this.target) && "fqn" in this.target
            ? this.target.fqn
            : this.resolveArg(context, this.target);
        const expr = `${targetExpr}${serializedArgs}`;
        return suppressBraces ? expr : `\${${expr}}`;
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function propertyAccess(target, args) {
    return new PropertyAccess(target, args);
}
exports.propertyAccess = propertyAccess;
// eslint-disable-next-line jsdoc/require-jsdoc
class ConditionalExpression extends TFExpression {
    constructor(condition, trueValue, falseValue) {
        super({ condition, trueValue, falseValue });
        this.condition = condition;
        this.trueValue = trueValue;
        this.falseValue = falseValue;
    }
    resolve(context) {
        const suppressBraces = context.suppressBraces;
        context.suppressBraces = true;
        const condition = this.resolveArg(context, this.condition);
        const trueValue = this.resolveArg(context, this.trueValue);
        const falseValue = this.resolveArg(context, this.falseValue);
        const expr = `${condition} ? ${trueValue} : ${falseValue}`;
        return suppressBraces ? expr : `\${${expr}}`;
    }
}
/**
 * creates an expression like `true ? 1 : 0`
 */
function conditional(condition, trueValue, falseValue) {
    return new ConditionalExpression(condition, trueValue, falseValue);
}
exports.conditional = conditional;
/**
 * Base class for Operator Expressions
 * @internal
 */
class OperatorExpression extends TFExpression {
    constructor(operator, left, right // optional for ! and - operator
    ) {
        super({ operator, leftValue: left, rightValue: right });
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    resolve(context) {
        const suppressBraces = context.suppressBraces;
        context.suppressBraces = true;
        const left = this.resolveArg(context, this.left);
        const right = this.right ? this.resolveArg(context, this.right) : undefined;
        let expr = "";
        switch (this.operator) {
            case "!": {
                expr = `!${left}`; // no braces needed as ! has highest precedence
                break;
            }
            case "-": {
                if (right) {
                    // subtraction
                    expr = `(${left} - ${right})`;
                }
                else {
                    // negation
                    expr = `-${left}`; // no braces needed as - has highest precedence
                }
                break;
            }
            default: {
                expr = `(${left} ${this.operator} ${right})`;
            }
        }
        return suppressBraces ? expr : `\${${expr}}`;
    }
}
exports.OperatorExpression = OperatorExpression;
// eslint-disable-next-line jsdoc/require-jsdoc
class FunctionCall extends TFExpression {
    constructor(name, args) {
        super({ name, args });
        this.name = name;
        this.args = args;
    }
    resolve(context) {
        const suppressBraces = context.suppressBraces;
        const originalIgnoreEscapes = context.ignoreEscapes;
        const originalWarnEscapes = context.warnEscapes;
        context.suppressBraces = true;
        context.ignoreEscapes = true;
        context.warnEscapes = true;
        const serializedArgs = this.args
            .map((arg) => this.resolveArg(context, arg))
            .join(", ");
        const expr = `${this.name}(${serializedArgs})`;
        context.ignoreEscapes = originalIgnoreEscapes;
        context.warnEscapes = originalWarnEscapes;
        return suppressBraces ? expr : `\${${expr}}`;
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function call(name, args) {
    return new FunctionCall(name, args);
}
exports.call = call;
exports.FOR_EXPRESSION_KEY = ref("key");
exports.FOR_EXPRESSION_VALUE = ref("val");
/**
 * https://developer.hashicorp.com/terraform/language/expressions/for
 */
class ForExpression extends TFExpression {
    constructor(input, valueExpression, keyExpression) {
        super({ input, valueExpression, keyExpression });
        this.input = input;
        this.valueExpression = valueExpression;
        this.keyExpression = keyExpression;
    }
    resolve(context) {
        const suppressBraces = context.suppressBraces;
        context.suppressBraces = true;
        const key = this.resolveArg(context, exports.FOR_EXPRESSION_KEY);
        const value = this.resolveArg(context, exports.FOR_EXPRESSION_VALUE);
        const input = this.resolveArg(context, this.input);
        const valueExpr = this.resolveArg(context, this.valueExpression);
        let expr;
        if (this.keyExpression) {
            const keyExpr = this.resolveArg(context, this.keyExpression);
            expr = `{ for ${key}, ${value} in ${input}: ${keyExpr} => ${valueExpr} }`;
        }
        else {
            expr = `[ for ${key}, ${value} in ${input}: ${valueExpr}]`;
        }
        return suppressBraces ? expr : `\${${expr}}`;
    }
}
/**
 * Creates a for expression, used for advanced internal use cases (e.g. in the @cdktf/aws-adapter)
 * It is currently not possible to use this via JSII in other languages. Usually you might want to
 * use TerraformIterator instead.
 *
 * @param input the input for the expression e.g. a list or an object
 * @param valueExpression will express the value e.g. [ for i in &lt;input&gt; : &lt;valueExpression&gt; ]
 * @param keyExpression if set will return an object e.g. { for k,v in &lt;input&gt; : &lt;keyExpression&gt; => &lt;valueExpression&gt;}
 * @returns a for expression
 *
 * The variables for key (for maps) / index (for lists) and value that are valid in the key- and valueExpression
 * can be referenced by using these constants: FOR_EXPRESSION_KEY and FOR_EXPRESSION_VALUE.
 *
 * Currently nesting for expressions is not supported due to this simplification.
 *
 * Currently does not support filtering elements (if clause) or grouping results
 */
function forExpression(input, valueExpression, keyExpression) {
    return new ForExpression(input, valueExpression, keyExpression);
}
exports.forExpression = forExpression;
// eslint-disable-next-line jsdoc/require-jsdoc
class Dependable extends TFExpression {
    constructor(dependable) {
        super(dependable);
        this.dependable = dependable;
    }
    resolve(context) {
        context.suppressBraces = true;
        return this.dependable.fqn;
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function dependable(dependable) {
    return token_1.Token.asString(new Dependable(dependable));
}
exports.dependable = dependable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGZFeHByZXNzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGZFeHByZXNzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdBLDBEQUF1RDtBQUN2RCwwQ0FBcUQ7QUFDckQsd0JBQXdCO0FBQ3hCLHVEQUFtRDtBQUVuRCwyQ0FBdUM7QUFFdkMsTUFBTSwwQkFBMEIsR0FBRywwQkFBMEIsQ0FBQztBQUU5RCwrQ0FBK0M7QUFDL0MsTUFBTSxZQUFhLFNBQVEscUJBQVM7SUFDeEIsVUFBVSxDQUFDLE9BQXdCLEVBQUUsR0FBUTtRQUNyRCxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pDLElBQUksb0JBQVksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDbEMsT0FBTyxXQUFXLENBQUM7U0FDcEI7UUFFRCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1NBQzdDO1FBRUQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxXQUFXO2lCQUNuQixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7U0FDbEI7UUFFRCxJQUFJLE9BQU8sV0FBVyxLQUFLLFFBQVEsSUFBSSxXQUFXLEtBQUssSUFBSSxFQUFFO1lBQzNELE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztpQkFDaEMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEdBQUcsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO2lCQUNoRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUNsQjtRQUVELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7O09BR0c7SUFDTyxZQUFZLENBQUMsR0FBVztRQUNoQyxPQUFPLEdBQUc7YUFDUCxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLGtCQUFrQjthQUN4QyxPQUFPLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsbUJBQW1CO0lBQ2pELENBQUM7SUFFTyxhQUFhLENBQUMsR0FBVyxFQUFFLFdBQWdCO1FBQ2pELE1BQU0sU0FBUyxHQUFHLG9CQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBRTVFLGlCQUFpQjtRQUNqQixJQUFJLGNBQWMsS0FBSyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxXQUFXLEtBQUssR0FBRztnQkFDeEIsV0FBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7Z0JBQzNCLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO2dCQUN6QixDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUM7Z0JBQ2hDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQztTQUMzQztRQUVELHlCQUF5QjtRQUN6QixJQUNFLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUM7WUFDL0IsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUM5QixjQUFjLEtBQUssQ0FBQyxFQUNwQjtZQUNBLE9BQU8sV0FBVyxDQUFDO1NBQ3BCO1FBRUQsK0NBQStDO1FBQy9DLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFDaEMsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUNwQixNQUFNLFVBQVUsR0FBRyxvQkFBWSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDOUMsTUFBTSxhQUFhLEdBQUcsb0JBQVksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZELE1BQU0sV0FBVyxHQUFHLG9CQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUVoRCxNQUFNLGNBQWMsR0FDbEIsYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBRS9ELGdHQUFnRztnQkFDaEcsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUVyQix5REFBeUQ7Z0JBQ3pELElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLGNBQWMsS0FBSyxDQUFDLEVBQUU7b0JBQy9ELFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNyQztnQkFFRCx1RUFBdUU7Z0JBQ3ZFLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLGNBQWMsS0FBSyxDQUFDLEVBQUU7b0JBQy9ELFNBQVMsR0FBRyxNQUFNLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO2lCQUNwQztnQkFFRCxNQUFNLFVBQVUsR0FDZCxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUM7b0JBQ3RCLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQztvQkFDMUIsQ0FBQyxDQUFDLE1BQU0sV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7Z0JBRTlCLE9BQU8sR0FBRyxTQUFTLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDckMsQ0FBQztTQUNGLENBQUMsQ0FBQztRQUVILE9BQU8sVUFBVSxLQUFLLEdBQUc7WUFDdkIsVUFBVSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7WUFDMUIsVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUM7WUFDeEIsQ0FBQyxDQUFDLFVBQVU7WUFDWixDQUFDLENBQUMsSUFBSSxVQUFVLEdBQUcsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUFFRCx3REFBd0Q7QUFDeEQsK0NBQStDO0FBQy9DLE1BQU0sU0FBVSxTQUFRLFlBQVk7SUFDbEMsWUFBNkIsR0FBVztRQUN0QyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFEZ0IsUUFBRyxHQUFILEdBQUcsQ0FBUTtJQUV4QyxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXdCO1FBQ3JDLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQzlDLE9BQU8sR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLHdDQUF3QztJQUNySCxDQUFDO0lBRU0sUUFBUTtRQUNiLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNsQixDQUFDO0NBQ0Y7QUFFRCwrQ0FBK0M7QUFDL0MsU0FBZ0IsU0FBUyxDQUFDLEdBQVc7SUFDbkMsT0FBTyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRkQsOEJBRUM7QUFFRCwrQ0FBK0M7QUFDL0MsTUFBTSxTQUFVLFNBQVEsWUFBWTtJQVFsQyxZQUNVLFVBQWtCLEVBQ2xCLFdBQTRCO1FBRXBDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUhWLGVBQVUsR0FBVixVQUFVLENBQVE7UUFDbEIsZ0JBQVcsR0FBWCxXQUFXLENBQWlCO1FBVHRDOzs7OztXQUtHO1FBQ0sseUJBQW9CLEdBQTJCLEVBQUUsQ0FBQztJQU0xRCxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXdCO1FBQ3JDLCtFQUErRTtRQUMvRSxNQUFNLGVBQWUsR0FBRyxnQ0FBYyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekQsTUFBTSxTQUFTLEdBQUcsZUFBZSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzdDLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7UUFDOUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFFOUIsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3JCLHdCQUF3QjtZQUN4QixJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxlQUFlLEVBQUU7Z0JBQzVELE1BQU0sR0FBRyxHQUFHLE1BQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNyQyxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsbUJBQW1CLENBQ2pDLElBQUksQ0FBQyxXQUFXLEVBQ2hCLGVBQWUsRUFDZixJQUFJLENBQUMsVUFBVSxDQUNoQixDQUFDO2dCQUVGLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUM7YUFDNUM7U0FDRjtRQUVELHVGQUF1RjtRQUN2RixJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN4QyxPQUFPLGNBQWM7Z0JBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDO2dCQUN0QyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztTQUNuRDtRQUVELE9BQU8sY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQztJQUNyRSxDQUFDO0NBQ0Y7QUFFRCwrQ0FBK0M7QUFDL0MsU0FBZ0IsR0FBRyxDQUFDLFVBQWtCLEVBQUUsS0FBc0I7SUFDNUQsT0FBTyxJQUFJLFNBQVMsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDMUMsQ0FBQztBQUZELGtCQUVDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsR0FBUTtJQUN6QyxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFGRCxnREFFQztBQUVELCtDQUErQztBQUMvQyxNQUFNLGNBQWUsU0FBUSxZQUFZO0lBQ3ZDLFlBQW9CLE1BQWtCLEVBQVUsSUFBa0I7UUFDaEUsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFETixXQUFNLEdBQU4sTUFBTSxDQUFZO1FBQVUsU0FBSSxHQUFKLElBQUksQ0FBYztJQUVsRSxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXdCO1FBQ3JDLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7UUFDOUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFFOUIsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLElBQUk7YUFDN0IsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDWCxJQUFJLEdBQUcsS0FBSyxHQUFHLEVBQUU7Z0JBQ2YsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUVELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3hDLE1BQU0sYUFBYSxHQUNqQixPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksMEJBQTBCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2xFLE1BQU0sYUFBYSxHQUNqQixPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksQ0FBQyxhQUFLLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXRELElBQUksYUFBYSxJQUFJLGFBQWEsRUFBRTtnQkFDbEMsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDO2FBQ2xCO1lBRUQsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ2xCLENBQUMsQ0FBQyxDQUFDLGtCQUFrQjthQUNwQixJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFWixNQUFNLFVBQVUsR0FDZCxzQkFBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxNQUFNO1lBQ3hELENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUc7WUFDakIsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU1QyxNQUFNLElBQUksR0FBRyxHQUFHLFVBQVUsR0FBRyxjQUFjLEVBQUUsQ0FBQztRQUU5QyxPQUFPLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDO0lBQy9DLENBQUM7Q0FDRjtBQUVELCtDQUErQztBQUMvQyxTQUFnQixjQUFjLENBQUMsTUFBa0IsRUFBRSxJQUFrQjtJQUNuRSxPQUFPLElBQUksY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQWdCLENBQUM7QUFDekQsQ0FBQztBQUZELHdDQUVDO0FBRUQsK0NBQStDO0FBQy9DLE1BQU0scUJBQXNCLFNBQVEsWUFBWTtJQUM5QyxZQUNVLFNBQXFCLEVBQ3JCLFNBQXFCLEVBQ3JCLFVBQXNCO1FBRTlCLEtBQUssQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUpwQyxjQUFTLEdBQVQsU0FBUyxDQUFZO1FBQ3JCLGNBQVMsR0FBVCxTQUFTLENBQVk7UUFDckIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUdoQyxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXdCO1FBQ3JDLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7UUFDOUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFFOUIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMzRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFN0QsTUFBTSxJQUFJLEdBQUcsR0FBRyxTQUFTLE1BQU0sU0FBUyxNQUFNLFVBQVUsRUFBRSxDQUFDO1FBRTNELE9BQU8sY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUM7SUFDL0MsQ0FBQztDQUNGO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixXQUFXLENBQ3pCLFNBQXFCLEVBQ3JCLFNBQXFCLEVBQ3JCLFVBQXNCO0lBRXRCLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFORCxrQ0FNQztBQW1CRDs7O0dBR0c7QUFDSCxNQUFhLGtCQUFtQixTQUFRLFlBQVk7SUFDbEQsWUFDVSxRQUFrQixFQUNsQixJQUFnQixFQUNoQixLQUFrQixDQUFDLGdDQUFnQzs7UUFFM0QsS0FBSyxDQUFDLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7UUFKaEQsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLFVBQUssR0FBTCxLQUFLLENBQWE7SUFHNUIsQ0FBQztJQUVNLE9BQU8sQ0FBQyxPQUF3QjtRQUNyQyxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDO1FBQzlDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBRTlCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUU1RSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7UUFDZCxRQUFRLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDckIsS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDUixJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLCtDQUErQztnQkFDbEUsTUFBTTthQUNQO1lBQ0QsS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDUixJQUFJLEtBQUssRUFBRTtvQkFDVCxjQUFjO29CQUNkLElBQUksR0FBRyxJQUFJLElBQUksTUFBTSxLQUFLLEdBQUcsQ0FBQztpQkFDL0I7cUJBQU07b0JBQ0wsV0FBVztvQkFDWCxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLCtDQUErQztpQkFDbkU7Z0JBQ0QsTUFBTTthQUNQO1lBQ0QsT0FBTyxDQUFDLENBQUM7Z0JBQ1AsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksS0FBSyxHQUFHLENBQUM7YUFDOUM7U0FDRjtRQUVELE9BQU8sY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUM7SUFDL0MsQ0FBQztDQUNGO0FBdkNELGdEQXVDQztBQUVELCtDQUErQztBQUMvQyxNQUFNLFlBQWEsU0FBUSxZQUFZO0lBQ3JDLFlBQW9CLElBQVksRUFBVSxJQUFrQjtRQUMxRCxLQUFLLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQURKLFNBQUksR0FBSixJQUFJLENBQVE7UUFBVSxTQUFJLEdBQUosSUFBSSxDQUFjO0lBRTVELENBQUM7SUFFTSxPQUFPLENBQUMsT0FBd0I7UUFDckMsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQztRQUM5QyxNQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDcEQsTUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDO1FBRWhELE9BQU8sQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQzlCLE9BQU8sQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQzdCLE9BQU8sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBRTNCLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJO2FBQzdCLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWQsTUFBTSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLGNBQWMsR0FBRyxDQUFDO1FBRS9DLE9BQU8sQ0FBQyxhQUFhLEdBQUcscUJBQXFCLENBQUM7UUFDOUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQztRQUUxQyxPQUFPLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDO0lBQy9DLENBQUM7Q0FDRjtBQUNELCtDQUErQztBQUMvQyxTQUFnQixJQUFJLENBQUMsSUFBWSxFQUFFLElBQWtCO0lBQ25ELE9BQU8sSUFBSSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBZ0IsQ0FBQztBQUNyRCxDQUFDO0FBRkQsb0JBRUM7QUFFWSxRQUFBLGtCQUFrQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoQyxRQUFBLG9CQUFvQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUUvQzs7R0FFRztBQUNILE1BQU0sYUFBYyxTQUFRLFlBQVk7SUFDdEMsWUFDVSxLQUFpQixFQUNqQixlQUEyQixFQUMzQixhQUEwQjtRQUVsQyxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFKekMsVUFBSyxHQUFMLEtBQUssQ0FBWTtRQUNqQixvQkFBZSxHQUFmLGVBQWUsQ0FBWTtRQUMzQixrQkFBYSxHQUFiLGFBQWEsQ0FBYTtJQUdwQyxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXdCO1FBQ3JDLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7UUFDOUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDOUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsMEJBQWtCLENBQUMsQ0FBQztRQUN6RCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSw0QkFBb0IsQ0FBQyxDQUFDO1FBQzdELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFakUsSUFBSSxJQUFZLENBQUM7UUFDakIsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUM3RCxJQUFJLEdBQUcsU0FBUyxHQUFHLEtBQUssS0FBSyxPQUFPLEtBQUssS0FBSyxPQUFPLE9BQU8sU0FBUyxJQUFJLENBQUM7U0FDM0U7YUFBTTtZQUNMLElBQUksR0FBRyxTQUFTLEdBQUcsS0FBSyxLQUFLLE9BQU8sS0FBSyxLQUFLLFNBQVMsR0FBRyxDQUFDO1NBQzVEO1FBRUQsT0FBTyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEdBQUcsQ0FBQztJQUMvQyxDQUFDO0NBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNILFNBQWdCLGFBQWEsQ0FDM0IsS0FBaUIsRUFDakIsZUFBMkIsRUFDM0IsYUFBMEI7SUFFMUIsT0FBTyxJQUFJLGFBQWEsQ0FDdEIsS0FBSyxFQUNMLGVBQWUsRUFDZixhQUFhLENBQ0MsQ0FBQztBQUNuQixDQUFDO0FBVkQsc0NBVUM7QUFFRCwrQ0FBK0M7QUFDL0MsTUFBTSxVQUFXLFNBQVEsWUFBWTtJQUNuQyxZQUFvQixVQUFnQztRQUNsRCxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7UUFEQSxlQUFVLEdBQVYsVUFBVSxDQUFzQjtJQUVwRCxDQUFDO0lBRU0sT0FBTyxDQUFDLE9BQXdCO1FBQ3JDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBRTlCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7SUFDN0IsQ0FBQztDQUNGO0FBQ0QsK0NBQStDO0FBQy9DLFNBQWdCLFVBQVUsQ0FBQyxVQUFnQztJQUN6RCxPQUFPLGFBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRkQsZ0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHsgSVJlc29sdmFibGUsIElSZXNvbHZlQ29udGV4dCB9IGZyb20gXCIuL3Rva2Vucy9yZXNvbHZhYmxlXCI7XG5pbXBvcnQgeyBJbnRyaW5zaWMgfSBmcm9tIFwiLi90b2tlbnMvcHJpdmF0ZS9pbnRyaW5zaWNcIjtcbmltcG9ydCB7IFRva2VuaXphdGlvbiwgVG9rZW4gfSBmcm9tIFwiLi90b2tlbnMvdG9rZW5cIjtcbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1TdGFjayB9IGZyb20gXCIuL3RlcnJhZm9ybS1zdGFja1wiO1xuaW1wb3J0IHsgSVRlcnJhZm9ybURlcGVuZGFibGUgfSBmcm9tIFwiLi90ZXJyYWZvcm0tZGVwZW5kYWJsZVwiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcblxuY29uc3QgVEVSUkFGT1JNX0lERU5USUZJRVJfUkVHRVggPSAvXltfYS16QS1aXVtfYS16QS1aMC05XSokLztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmNsYXNzIFRGRXhwcmVzc2lvbiBleHRlbmRzIEludHJpbnNpYyBpbXBsZW1lbnRzIElSZXNvbHZhYmxlIHtcbiAgcHJvdGVjdGVkIHJlc29sdmVBcmcoY29udGV4dDogSVJlc29sdmVDb250ZXh0LCBhcmc6IGFueSk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzb2x2ZWRBcmcgPSBjb250ZXh0LnJlc29sdmUoYXJnKTtcbiAgICBpZiAoVG9rZW5pemF0aW9uLmlzUmVzb2x2YWJsZShhcmcpKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRBcmc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVTdHJpbmcoYXJnLCByZXNvbHZlZEFyZyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZWRBcmcpKSB7XG4gICAgICByZXR1cm4gYFske3Jlc29sdmVkQXJnXG4gICAgICAgIC5tYXAoKF8sIGluZGV4KSA9PiB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgYXJnW2luZGV4XSkpXG4gICAgICAgIC5qb2luKFwiLCBcIil9XWA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXNvbHZlZEFyZyA9PT0gXCJvYmplY3RcIiAmJiByZXNvbHZlZEFyZyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGB7JHtPYmplY3Qua2V5cyhyZXNvbHZlZEFyZylcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgXCIke2tleX1cIiA9ICR7dGhpcy5yZXNvbHZlQXJnKGNvbnRleHQsIGFyZ1trZXldKX1gKVxuICAgICAgICAuam9pbihcIiwgXCIpfX1gO1xuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZEFyZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGUgc3RyaW5nIHJlbW92ZXMgY2hhcmFjdGVycyBmcm9tIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gVGVycmFmb3JtIG9yIEpTT05cbiAgICogSXQgbXVzdCBvbmx5IGJlIHVzZWQgb24gbm9uLXRva2VuIHZhbHVlc1xuICAgKi9cbiAgcHJvdGVjdGVkIGVzY2FwZVN0cmluZyhzdHI6IHN0cmluZykge1xuICAgIHJldHVybiBzdHJcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSAvLyBlc2NhcGUgbmV3bGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXCR7L2csIFwiJCQke1wiKTsgLy8gZXNjYXBlICR7IHRvICQke1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlU3RyaW5nKHN0cjogc3RyaW5nLCByZXNvbHZlZEFyZzogYW55KSB7XG4gICAgY29uc3QgdG9rZW5MaXN0ID0gVG9rZW5pemF0aW9uLnJldmVyc2VTdHJpbmcoc3RyKTtcbiAgICBjb25zdCBudW1iZXJPZlRva2VucyA9IHRva2VuTGlzdC50b2tlbnMubGVuZ3RoICsgdG9rZW5MaXN0LmludHJpbnNpYy5sZW5ndGg7XG5cbiAgICAvLyBTdHJpbmcgbGl0ZXJhbFxuICAgIGlmIChudW1iZXJPZlRva2VucyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQXJnICE9PSBgXCJgICYmXG4gICAgICAgIHJlc29sdmVkQXJnLnN0YXJ0c1dpdGgoJ1wiJykgJiZcbiAgICAgICAgcmVzb2x2ZWRBcmcuZW5kc1dpdGgoJ1wiJylcbiAgICAgICAgPyB0aGlzLmVzY2FwZVN0cmluZyhyZXNvbHZlZEFyZylcbiAgICAgICAgOiBgXCIke3RoaXMuZXNjYXBlU3RyaW5nKHJlc29sdmVkQXJnKX1cImA7XG4gICAgfVxuXG4gICAgLy8gT25seSBhIHRva2VuIHJlZmVyZW5jZVxuICAgIGlmIChcbiAgICAgIHRva2VuTGlzdC5saXRlcmFscy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHRva2VuTGlzdC5lc2NhcGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgbnVtYmVyT2ZUb2tlbnMgPT09IDFcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNvbHZlZEFyZztcbiAgICB9XG5cbiAgICAvLyBTdHJpbmcgbGl0ZXJhbCArIHRva2VuIHJlZmVyZW5jZSBjb21iaW5hdGlvblxuICAgIGNvbnN0IGpvaW5SZXN1bHQgPSB0b2tlbkxpc3Quam9pbih7XG4gICAgICBqb2luOiAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgICAgY29uc3QgbGVmdFRva2VucyA9IFRva2VuaXphdGlvbi5yZXZlcnNlKGxlZnQpO1xuICAgICAgICBjb25zdCBsZWZ0VG9rZW5MaXN0ID0gVG9rZW5pemF0aW9uLnJldmVyc2VTdHJpbmcobGVmdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0VG9rZW5zID0gVG9rZW5pemF0aW9uLnJldmVyc2UocmlnaHQpO1xuXG4gICAgICAgIGNvbnN0IGxlZnRUb2tlbkNvdW50ID1cbiAgICAgICAgICBsZWZ0VG9rZW5MaXN0LmludHJpbnNpYy5sZW5ndGggKyBsZWZ0VG9rZW5MaXN0LnRva2Vucy5sZW5ndGg7XG5cbiAgICAgICAgLy8gaWYgbGVmdCBpcyBtaXhlZCwgbmVlZHMgdG8gYmUgbGVmdCBhbG9uZSAoYmVjYXVzZSBpdCdzIGEgcmVzdWx0IG9mIGEgcHJldmlvdXMgam9pbiBpdGVyYXRpb24pXG4gICAgICAgIGxldCBsZWZ0VmFsdWUgPSBsZWZ0O1xuXG4gICAgICAgIC8vIGlmIGxlZnQgaXMgYSBzdHJpbmcgbGl0ZXJhbCwgdGhlbiB3ZSBuZWVkIHRvIGVzY2FwZSBpdFxuICAgICAgICBpZiAobGVmdFRva2VuTGlzdC5saXRlcmFscy5sZW5ndGggPT09IDEgJiYgbGVmdFRva2VuQ291bnQgPT09IDApIHtcbiAgICAgICAgICBsZWZ0VmFsdWUgPSB0aGlzLmVzY2FwZVN0cmluZyhsZWZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlZnQgaXMgb25seSBhIHRva2VuLCBuZWVkcyB0byBiZSB3cmFwcGVkIGFzIHRlcnJhZm9ybSBleHByZXNzaW9uXG4gICAgICAgIGlmIChsZWZ0VG9rZW5MaXN0LmxpdGVyYWxzLmxlbmd0aCA9PT0gMCAmJiBsZWZ0VG9rZW5Db3VudCA9PT0gMSkge1xuICAgICAgICAgIGxlZnRWYWx1ZSA9IGBcXCR7JHtsZWZ0VG9rZW5zWzBdfX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmlnaHRWYWx1ZSA9XG4gICAgICAgICAgcmlnaHRUb2tlbnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IHRoaXMuZXNjYXBlU3RyaW5nKHJpZ2h0KVxuICAgICAgICAgICAgOiBgXFwkeyR7cmlnaHRUb2tlbnNbMF19fWA7XG5cbiAgICAgICAgcmV0dXJuIGAke2xlZnRWYWx1ZX0ke3JpZ2h0VmFsdWV9YDtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gam9pblJlc3VsdCAhPT0gYFwiYCAmJlxuICAgICAgam9pblJlc3VsdC5zdGFydHNXaXRoKCdcIicpICYmXG4gICAgICBqb2luUmVzdWx0LmVuZHNXaXRoKCdcIicpXG4gICAgICA/IGpvaW5SZXN1bHRcbiAgICAgIDogYFwiJHtqb2luUmVzdWx0fVwiYDtcbiAgfVxufVxuXG4vLyBBIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYW4gaW5wdXQgdmFsdWUgdG8gYmUgZXNjYXBlZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmNsYXNzIFJhd1N0cmluZyBleHRlbmRzIFRGRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RyOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzdHIpO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmUoY29udGV4dDogSVJlc29sdmVDb250ZXh0KSB7XG4gICAgY29uc3QgcXRzID0gY29udGV4dC5zdXBwcmVzc0JyYWNlcyA/IGBcImAgOiBgYDtcbiAgICByZXR1cm4gYCR7cXRzfSR7dGhpcy5lc2NhcGVTdHJpbmcodGhpcy5zdHIpLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpfSR7cXRzfWA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHI7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiByYXdTdHJpbmcoc3RyOiBzdHJpbmcpOiBJUmVzb2x2YWJsZSB7XG4gIHJldHVybiBuZXcgUmF3U3RyaW5nKHN0cik7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5jbGFzcyBSZWZlcmVuY2UgZXh0ZW5kcyBURkV4cHJlc3Npb24ge1xuICAvKipcbiAgICogQSBzaW5nbGUgcmVmZXJlbmNlIGNvdWxkIGJlIHVzZWQgaW4gbXVsdGlwbGUgc3RhY2tzLFxuICAgKiBlLmcuIGlmIHdlIGV4cG9zZSB0aGUgcmVmIGRpcmVjdGx5IG9yIGFzIHRva2VuIG9uIHRoZSBzdGFjay5cbiAgICogV2UgbmVlZCB0byBzdG9yZSB0aGUgaWRlbnRpZmllciBmb3IgZWFjaCBzdGFjayxcbiAgICogc28gdGhhdCB0aGUgcmVzb2x2ZWQgaWRlbnRpZmllciBzdHJpbmcgbWF0Y2hlcyB0aGUgc3RhY2sgaXQncyByZXNvbHZlZCBpbi5cbiAgICovXG4gIHByaXZhdGUgY3Jvc3NTdGFja0lkZW50aWZpZXI6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZGVudGlmaWVyOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSBvcmlnaW5TdGFjaz86IFRlcnJhZm9ybVN0YWNrXG4gICkge1xuICAgIHN1cGVyKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmUoY29udGV4dDogSVJlc29sdmVDb250ZXh0KTogc3RyaW5nIHtcbiAgICAvLyBXZSBjaGVjayBmb3IgY3Jvc3Mgc3RhY2sgcmVmZXJlbmNlcyBvbiBwcmVwYXJhdGlvbiwgc2V0dGluZyBhIG5ldyBpZGVudGlmaWVyXG4gICAgY29uc3QgcmVzb2x1dGlvblN0YWNrID0gVGVycmFmb3JtU3RhY2sub2YoY29udGV4dC5zY29wZSk7XG4gICAgY29uc3Qgc3RhY2tOYW1lID0gcmVzb2x1dGlvblN0YWNrLnRvU3RyaW5nKCk7XG4gICAgY29uc3Qgc3VwcHJlc3NCcmFjZXMgPSBjb250ZXh0LnN1cHByZXNzQnJhY2VzO1xuICAgIGNvbnRleHQuc3VwcHJlc3NCcmFjZXMgPSB0cnVlO1xuXG4gICAgaWYgKGNvbnRleHQucHJlcGFyaW5nKSB7XG4gICAgICAvLyBDcm9zcyBzdGFjayByZWZlcmVuY2VcbiAgICAgIGlmICh0aGlzLm9yaWdpblN0YWNrICYmIHRoaXMub3JpZ2luU3RhY2sgIT09IHJlc29sdXRpb25TdGFjaykge1xuICAgICAgICBjb25zdCBhcHAgPSBBcHAub2YodGhpcy5vcmlnaW5TdGFjayk7XG4gICAgICAgIGNvbnN0IGNzciA9IGFwcC5jcm9zc1N0YWNrUmVmZXJlbmNlKFxuICAgICAgICAgIHRoaXMub3JpZ2luU3RhY2ssXG4gICAgICAgICAgcmVzb2x1dGlvblN0YWNrLFxuICAgICAgICAgIHRoaXMuaWRlbnRpZmllclxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuY3Jvc3NTdGFja0lkZW50aWZpZXJbc3RhY2tOYW1lXSA9IGNzcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgY3Jvc3Mgc3RhY2sgcmVmZXJlbmNlIHdlIHdpbGwgcmVzb2x2ZSB0byBhIHJlZmVyZW5jZSB3aXRoaW4gdGhpcyBzdGFjay5cbiAgICBpZiAodGhpcy5jcm9zc1N0YWNrSWRlbnRpZmllcltzdGFja05hbWVdKSB7XG4gICAgICByZXR1cm4gc3VwcHJlc3NCcmFjZXNcbiAgICAgICAgPyB0aGlzLmNyb3NzU3RhY2tJZGVudGlmaWVyW3N0YWNrTmFtZV1cbiAgICAgICAgOiBgXFwkeyR7dGhpcy5jcm9zc1N0YWNrSWRlbnRpZmllcltzdGFja05hbWVdfX1gO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBwcmVzc0JyYWNlcyA/IHRoaXMuaWRlbnRpZmllciA6IGBcXCR7JHt0aGlzLmlkZW50aWZpZXJ9fWA7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiByZWYoaWRlbnRpZmllcjogc3RyaW5nLCBzdGFjaz86IFRlcnJhZm9ybVN0YWNrKTogSVJlc29sdmFibGUge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZShpZGVudGlmaWVyLCBzdGFjayk7XG59XG5cbi8qKlxuICogbWFya3MgdGhlIGFyZ3VtZW50IGFzIGJlaW5nIHVzZWQgaW4gYSB0ZXJyYWZvcm0gZXhwcmVzc2lvblxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2lkZVRmRXhwcmVzc2lvbihhcmc6IGFueSkge1xuICByZXR1cm4gYXJnO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuY2xhc3MgUHJvcGVydHlBY2Nlc3MgZXh0ZW5kcyBURkV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhcmdldDogRXhwcmVzc2lvbiwgcHJpdmF0ZSBhcmdzOiBFeHByZXNzaW9uW10pIHtcbiAgICBzdXBlcih7IHRhcmdldCwgYXJncyB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKGNvbnRleHQ6IElSZXNvbHZlQ29udGV4dCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3VwcHJlc3NCcmFjZXMgPSBjb250ZXh0LnN1cHByZXNzQnJhY2VzO1xuICAgIGNvbnRleHQuc3VwcHJlc3NCcmFjZXMgPSB0cnVlO1xuXG4gICAgY29uc3Qgc2VyaWFsaXplZEFyZ3MgPSB0aGlzLmFyZ3NcbiAgICAgIC5tYXAoKGFyZykgPT4ge1xuICAgICAgICBpZiAoYXJnID09PSBgKmApIHtcbiAgICAgICAgICByZXR1cm4gXCJbKl1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgYXJnKTtcbiAgICAgICAgY29uc3QgaXNQbGFpblN0cmluZyA9XG4gICAgICAgICAgdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiAmJiBURVJSQUZPUk1fSURFTlRJRklFUl9SRUdFWC50ZXN0KGFyZyk7XG4gICAgICAgIGNvbnN0IGlzUGxhaW5OdW1iZXIgPVxuICAgICAgICAgIHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIgJiYgIVRva2VuLmlzVW5yZXNvbHZlZChhcmcpO1xuXG4gICAgICAgIGlmIChpc1BsYWluU3RyaW5nIHx8IGlzUGxhaW5OdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gYC4ke2FyZ31gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGBbJHthfV1gO1xuICAgICAgfSkgLy8gcHJvcGVydHkgYWNjZXNzXG4gICAgICAuam9pbihcIlwiKTtcblxuICAgIGNvbnN0IHRhcmdldEV4cHIgPVxuICAgICAgQ29uc3RydWN0LmlzQ29uc3RydWN0KHRoaXMudGFyZ2V0KSAmJiBcImZxblwiIGluIHRoaXMudGFyZ2V0XG4gICAgICAgID8gdGhpcy50YXJnZXQuZnFuXG4gICAgICAgIDogdGhpcy5yZXNvbHZlQXJnKGNvbnRleHQsIHRoaXMudGFyZ2V0KTtcblxuICAgIGNvbnN0IGV4cHIgPSBgJHt0YXJnZXRFeHByfSR7c2VyaWFsaXplZEFyZ3N9YDtcblxuICAgIHJldHVybiBzdXBwcmVzc0JyYWNlcyA/IGV4cHIgOiBgXFwkeyR7ZXhwcn19YDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5QWNjZXNzKHRhcmdldDogRXhwcmVzc2lvbiwgYXJnczogRXhwcmVzc2lvbltdKSB7XG4gIHJldHVybiBuZXcgUHJvcGVydHlBY2Nlc3ModGFyZ2V0LCBhcmdzKSBhcyBJUmVzb2x2YWJsZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmNsYXNzIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBleHRlbmRzIFRGRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY29uZGl0aW9uOiBFeHByZXNzaW9uLFxuICAgIHByaXZhdGUgdHJ1ZVZhbHVlOiBFeHByZXNzaW9uLFxuICAgIHByaXZhdGUgZmFsc2VWYWx1ZTogRXhwcmVzc2lvblxuICApIHtcbiAgICBzdXBlcih7IGNvbmRpdGlvbiwgdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlIH0pO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmUoY29udGV4dDogSVJlc29sdmVDb250ZXh0KTogc3RyaW5nIHtcbiAgICBjb25zdCBzdXBwcmVzc0JyYWNlcyA9IGNvbnRleHQuc3VwcHJlc3NCcmFjZXM7XG4gICAgY29udGV4dC5zdXBwcmVzc0JyYWNlcyA9IHRydWU7XG5cbiAgICBjb25zdCBjb25kaXRpb24gPSB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgdGhpcy5jb25kaXRpb24pO1xuICAgIGNvbnN0IHRydWVWYWx1ZSA9IHRoaXMucmVzb2x2ZUFyZyhjb250ZXh0LCB0aGlzLnRydWVWYWx1ZSk7XG4gICAgY29uc3QgZmFsc2VWYWx1ZSA9IHRoaXMucmVzb2x2ZUFyZyhjb250ZXh0LCB0aGlzLmZhbHNlVmFsdWUpO1xuXG4gICAgY29uc3QgZXhwciA9IGAke2NvbmRpdGlvbn0gPyAke3RydWVWYWx1ZX0gOiAke2ZhbHNlVmFsdWV9YDtcblxuICAgIHJldHVybiBzdXBwcmVzc0JyYWNlcyA/IGV4cHIgOiBgXFwkeyR7ZXhwcn19YDtcbiAgfVxufVxuXG4vKipcbiAqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiBsaWtlIGB0cnVlID8gMSA6IDBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb25hbChcbiAgY29uZGl0aW9uOiBFeHByZXNzaW9uLFxuICB0cnVlVmFsdWU6IEV4cHJlc3Npb24sXG4gIGZhbHNlVmFsdWU6IEV4cHJlc3Npb25cbikge1xuICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbihjb25kaXRpb24sIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSk7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2xhbmd1YWdlL2V4cHJlc3Npb25zL29wZXJhdG9yc1xuZXhwb3J0IHR5cGUgT3BlcmF0b3IgPVxuICB8IFwiIVwiXG4gIHwgXCItXCJcbiAgfCBcIipcIlxuICB8IFwiL1wiXG4gIHwgXCIlXCJcbiAgfCBcIitcIlxuICB8IFwiPlwiXG4gIHwgXCI+PVwiXG4gIHwgXCI8XCJcbiAgfCBcIjw9XCJcbiAgfCBcIj09XCJcbiAgfCBcIiE9XCJcbiAgfCBcIiYmXCJcbiAgfCBcInx8XCI7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgT3BlcmF0b3IgRXhwcmVzc2lvbnNcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgT3BlcmF0b3JFeHByZXNzaW9uIGV4dGVuZHMgVEZFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBvcGVyYXRvcjogT3BlcmF0b3IsXG4gICAgcHJpdmF0ZSBsZWZ0OiBFeHByZXNzaW9uLFxuICAgIHByaXZhdGUgcmlnaHQ/OiBFeHByZXNzaW9uIC8vIG9wdGlvbmFsIGZvciAhIGFuZCAtIG9wZXJhdG9yXG4gICkge1xuICAgIHN1cGVyKHsgb3BlcmF0b3IsIGxlZnRWYWx1ZTogbGVmdCwgcmlnaHRWYWx1ZTogcmlnaHQgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZShjb250ZXh0OiBJUmVzb2x2ZUNvbnRleHQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHN1cHByZXNzQnJhY2VzID0gY29udGV4dC5zdXBwcmVzc0JyYWNlcztcbiAgICBjb250ZXh0LnN1cHByZXNzQnJhY2VzID0gdHJ1ZTtcblxuICAgIGNvbnN0IGxlZnQgPSB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgdGhpcy5sZWZ0KTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQgPyB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgdGhpcy5yaWdodCkgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgZXhwciA9IFwiXCI7XG4gICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiIVwiOiB7XG4gICAgICAgIGV4cHIgPSBgISR7bGVmdH1gOyAvLyBubyBicmFjZXMgbmVlZGVkIGFzICEgaGFzIGhpZ2hlc3QgcHJlY2VkZW5jZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgLy8gc3VidHJhY3Rpb25cbiAgICAgICAgICBleHByID0gYCgke2xlZnR9IC0gJHtyaWdodH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBuZWdhdGlvblxuICAgICAgICAgIGV4cHIgPSBgLSR7bGVmdH1gOyAvLyBubyBicmFjZXMgbmVlZGVkIGFzIC0gaGFzIGhpZ2hlc3QgcHJlY2VkZW5jZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBleHByID0gYCgke2xlZnR9ICR7dGhpcy5vcGVyYXRvcn0gJHtyaWdodH0pYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwcHJlc3NCcmFjZXMgPyBleHByIDogYFxcJHske2V4cHJ9fWA7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmNsYXNzIEZ1bmN0aW9uQ2FsbCBleHRlbmRzIFRGRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmFtZTogc3RyaW5nLCBwcml2YXRlIGFyZ3M6IEV4cHJlc3Npb25bXSkge1xuICAgIHN1cGVyKHsgbmFtZSwgYXJncyB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKGNvbnRleHQ6IElSZXNvbHZlQ29udGV4dCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3VwcHJlc3NCcmFjZXMgPSBjb250ZXh0LnN1cHByZXNzQnJhY2VzO1xuICAgIGNvbnN0IG9yaWdpbmFsSWdub3JlRXNjYXBlcyA9IGNvbnRleHQuaWdub3JlRXNjYXBlcztcbiAgICBjb25zdCBvcmlnaW5hbFdhcm5Fc2NhcGVzID0gY29udGV4dC53YXJuRXNjYXBlcztcblxuICAgIGNvbnRleHQuc3VwcHJlc3NCcmFjZXMgPSB0cnVlO1xuICAgIGNvbnRleHQuaWdub3JlRXNjYXBlcyA9IHRydWU7XG4gICAgY29udGV4dC53YXJuRXNjYXBlcyA9IHRydWU7XG5cbiAgICBjb25zdCBzZXJpYWxpemVkQXJncyA9IHRoaXMuYXJnc1xuICAgICAgLm1hcCgoYXJnKSA9PiB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgYXJnKSlcbiAgICAgIC5qb2luKFwiLCBcIik7XG5cbiAgICBjb25zdCBleHByID0gYCR7dGhpcy5uYW1lfSgke3NlcmlhbGl6ZWRBcmdzfSlgO1xuXG4gICAgY29udGV4dC5pZ25vcmVFc2NhcGVzID0gb3JpZ2luYWxJZ25vcmVFc2NhcGVzO1xuICAgIGNvbnRleHQud2FybkVzY2FwZXMgPSBvcmlnaW5hbFdhcm5Fc2NhcGVzO1xuXG4gICAgcmV0dXJuIHN1cHByZXNzQnJhY2VzID8gZXhwciA6IGBcXCR7JHtleHByfX1gO1xuICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGwobmFtZTogc3RyaW5nLCBhcmdzOiBFeHByZXNzaW9uW10pIHtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwobmFtZSwgYXJncykgYXMgSVJlc29sdmFibGU7XG59XG5cbmV4cG9ydCBjb25zdCBGT1JfRVhQUkVTU0lPTl9LRVkgPSByZWYoXCJrZXlcIik7XG5leHBvcnQgY29uc3QgRk9SX0VYUFJFU1NJT05fVkFMVUUgPSByZWYoXCJ2YWxcIik7XG5cbi8qKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vbGFuZ3VhZ2UvZXhwcmVzc2lvbnMvZm9yXG4gKi9cbmNsYXNzIEZvckV4cHJlc3Npb24gZXh0ZW5kcyBURkV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlucHV0OiBFeHByZXNzaW9uLFxuICAgIHByaXZhdGUgdmFsdWVFeHByZXNzaW9uOiBFeHByZXNzaW9uLFxuICAgIHByaXZhdGUga2V5RXhwcmVzc2lvbj86IEV4cHJlc3Npb25cbiAgKSB7XG4gICAgc3VwZXIoeyBpbnB1dCwgdmFsdWVFeHByZXNzaW9uLCBrZXlFeHByZXNzaW9uIH0pO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmUoY29udGV4dDogSVJlc29sdmVDb250ZXh0KTogc3RyaW5nIHtcbiAgICBjb25zdCBzdXBwcmVzc0JyYWNlcyA9IGNvbnRleHQuc3VwcHJlc3NCcmFjZXM7XG4gICAgY29udGV4dC5zdXBwcmVzc0JyYWNlcyA9IHRydWU7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5yZXNvbHZlQXJnKGNvbnRleHQsIEZPUl9FWFBSRVNTSU9OX0tFWSk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgRk9SX0VYUFJFU1NJT05fVkFMVUUpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5yZXNvbHZlQXJnKGNvbnRleHQsIHRoaXMuaW5wdXQpO1xuICAgIGNvbnN0IHZhbHVlRXhwciA9IHRoaXMucmVzb2x2ZUFyZyhjb250ZXh0LCB0aGlzLnZhbHVlRXhwcmVzc2lvbik7XG5cbiAgICBsZXQgZXhwcjogc3RyaW5nO1xuICAgIGlmICh0aGlzLmtleUV4cHJlc3Npb24pIHtcbiAgICAgIGNvbnN0IGtleUV4cHIgPSB0aGlzLnJlc29sdmVBcmcoY29udGV4dCwgdGhpcy5rZXlFeHByZXNzaW9uKTtcbiAgICAgIGV4cHIgPSBgeyBmb3IgJHtrZXl9LCAke3ZhbHVlfSBpbiAke2lucHV0fTogJHtrZXlFeHByfSA9PiAke3ZhbHVlRXhwcn0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSBgWyBmb3IgJHtrZXl9LCAke3ZhbHVlfSBpbiAke2lucHV0fTogJHt2YWx1ZUV4cHJ9XWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cHByZXNzQnJhY2VzID8gZXhwciA6IGBcXCR7JHtleHByfX1gO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZvciBleHByZXNzaW9uLCB1c2VkIGZvciBhZHZhbmNlZCBpbnRlcm5hbCB1c2UgY2FzZXMgKGUuZy4gaW4gdGhlIEBjZGt0Zi9hd3MtYWRhcHRlcilcbiAqIEl0IGlzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gdXNlIHRoaXMgdmlhIEpTSUkgaW4gb3RoZXIgbGFuZ3VhZ2VzLiBVc3VhbGx5IHlvdSBtaWdodCB3YW50IHRvXG4gKiB1c2UgVGVycmFmb3JtSXRlcmF0b3IgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGlucHV0IGZvciB0aGUgZXhwcmVzc2lvbiBlLmcuIGEgbGlzdCBvciBhbiBvYmplY3RcbiAqIEBwYXJhbSB2YWx1ZUV4cHJlc3Npb24gd2lsbCBleHByZXNzIHRoZSB2YWx1ZSBlLmcuIFsgZm9yIGkgaW4gJmx0O2lucHV0Jmd0OyA6ICZsdDt2YWx1ZUV4cHJlc3Npb24mZ3Q7IF1cbiAqIEBwYXJhbSBrZXlFeHByZXNzaW9uIGlmIHNldCB3aWxsIHJldHVybiBhbiBvYmplY3QgZS5nLiB7IGZvciBrLHYgaW4gJmx0O2lucHV0Jmd0OyA6ICZsdDtrZXlFeHByZXNzaW9uJmd0OyA9PiAmbHQ7dmFsdWVFeHByZXNzaW9uJmd0O31cbiAqIEByZXR1cm5zIGEgZm9yIGV4cHJlc3Npb25cbiAqXG4gKiBUaGUgdmFyaWFibGVzIGZvciBrZXkgKGZvciBtYXBzKSAvIGluZGV4IChmb3IgbGlzdHMpIGFuZCB2YWx1ZSB0aGF0IGFyZSB2YWxpZCBpbiB0aGUga2V5LSBhbmQgdmFsdWVFeHByZXNzaW9uXG4gKiBjYW4gYmUgcmVmZXJlbmNlZCBieSB1c2luZyB0aGVzZSBjb25zdGFudHM6IEZPUl9FWFBSRVNTSU9OX0tFWSBhbmQgRk9SX0VYUFJFU1NJT05fVkFMVUUuXG4gKlxuICogQ3VycmVudGx5IG5lc3RpbmcgZm9yIGV4cHJlc3Npb25zIGlzIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIHRoaXMgc2ltcGxpZmljYXRpb24uXG4gKlxuICogQ3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZmlsdGVyaW5nIGVsZW1lbnRzIChpZiBjbGF1c2UpIG9yIGdyb3VwaW5nIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckV4cHJlc3Npb24oXG4gIGlucHV0OiBFeHByZXNzaW9uLFxuICB2YWx1ZUV4cHJlc3Npb246IEV4cHJlc3Npb24sXG4gIGtleUV4cHJlc3Npb24/OiBFeHByZXNzaW9uXG4pIHtcbiAgcmV0dXJuIG5ldyBGb3JFeHByZXNzaW9uKFxuICAgIGlucHV0LFxuICAgIHZhbHVlRXhwcmVzc2lvbixcbiAgICBrZXlFeHByZXNzaW9uXG4gICkgYXMgSVJlc29sdmFibGU7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5jbGFzcyBEZXBlbmRhYmxlIGV4dGVuZHMgVEZFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkZXBlbmRhYmxlOiBJVGVycmFmb3JtRGVwZW5kYWJsZSkge1xuICAgIHN1cGVyKGRlcGVuZGFibGUpO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmUoY29udGV4dDogSVJlc29sdmVDb250ZXh0KTogc3RyaW5nIHtcbiAgICBjb250ZXh0LnN1cHByZXNzQnJhY2VzID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLmRlcGVuZGFibGUuZnFuO1xuICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlcGVuZGFibGUoZGVwZW5kYWJsZTogSVRlcnJhZm9ybURlcGVuZGFibGUpOiBzdHJpbmcge1xuICByZXR1cm4gVG9rZW4uYXNTdHJpbmcobmV3IERlcGVuZGFibGUoZGVwZW5kYWJsZSkpO1xufVxuXG5leHBvcnQgdHlwZSBFeHByZXNzaW9uID1cbiAgfCBSZWZlcmVuY2VcbiAgfCBGdW5jdGlvbkNhbGxcbiAgfCBQcm9wZXJ0eUFjY2Vzc1xuICB8IENvbmRpdGlvbmFsRXhwcmVzc2lvblxuICB8IE9wZXJhdG9yRXhwcmVzc2lvblxuICB8IERlcGVuZGFibGVcbiAgfCBGb3JFeHByZXNzaW9uXG4gIHwgc3RyaW5nXG4gIHwgc3RyaW5nW11cbiAgfCBudW1iZXJcbiAgfCBib29sZWFuXG4gIHwgSVJlc29sdmFibGVcbiAgfCB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIHwgbnVsbFxuICB8IGFueSAvLyB1bHRpbWF0ZWx5IGFueSB2YWxpZCBUZXJyYWZvcm0gdHlwZSBjYW4gYmUgdXNlZCBhcyBhbiBleHByZXNzaW9uXG4gIHwgYW55W107XG4iXX0=