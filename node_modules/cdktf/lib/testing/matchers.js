"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPlanSuccessfully = exports.toBeValidTerraform = exports.getToHaveProviderWithProperties = exports.getToHaveResourceWithProperties = exports.getToHaveDataSourceWithProperties = exports.asymetricDeepEqualIgnoringObjectCasing = exports.returnMatcherToJest = exports.AssertionReturn = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const fs = require("fs");
const path = require("path");
const child_process_1 = require("child_process");
const util_1 = require("../util");
/**
 * Class representing the contents of a return by an assertion
 */
class AssertionReturn {
    /**
     * Create an AssertionReturn
     * @param message - String message containing information about the result of the assertion
     * @param pass - Boolean pass denoting the success of the assertion
     */
    constructor(message, pass) {
        this.message = message;
        this.pass = pass;
    }
}
_a = JSII_RTTI_SYMBOL_1;
AssertionReturn[_a] = { fqn: "cdktf.testingMatchers.AssertionReturn", version: "0.17.3" };
exports.AssertionReturn = AssertionReturn;
/**
 * Reformats the contents of the base testing matcher return type AssertionReturn into type useable by jest
 * @param toReturn
 * @returns {MatcherReturnJest}
 */
function returnMatcherToJest(toReturn) {
    return {
        message: () => toReturn.message,
        pass: toReturn.pass,
    };
}
exports.returnMatcherToJest = returnMatcherToJest;
/**
 * Compares expected and received. All expected properties are matched and considered equal even if
 * there are more properties in the received object than in the expected object in which case it will still return true.
 * @param expected
 * @param received
 * @returns {boolean}
 */
function asymetricDeepEqualIgnoringObjectCasing(expected, received) {
    switch (typeof expected) {
        case "object":
            if (Array.isArray(expected)) {
                return (Array.isArray(received) &&
                    expected.length === received.length &&
                    expected.every((item, index) => asymetricDeepEqualIgnoringObjectCasing(item, received[index]) // recursively compare arrays
                    ));
            }
            if (expected === null && received === null) {
                return true;
            }
            if (expected === undefined && received === undefined) {
                return true;
            }
            if (expected === null || received === null) {
                return false;
            }
            // recursively compare objects and allow snake case as well as camel case
            return Object.keys(expected).every((key) => {
                if (received[key] !== undefined) {
                    return asymetricDeepEqualIgnoringObjectCasing(expected[key], received[key]);
                }
                if (received[(0, util_1.snakeCase)(key)] !== undefined) {
                    return asymetricDeepEqualIgnoringObjectCasing(expected[key], received[(0, util_1.snakeCase)(key)]);
                }
                return false;
            });
        default:
            return expected === received;
    }
}
exports.asymetricDeepEqualIgnoringObjectCasing = asymetricDeepEqualIgnoringObjectCasing;
const defaultPassEvaluation = (items, assertedProperties) => {
    return Object.values(items).some((item) => asymetricDeepEqualIgnoringObjectCasing(assertedProperties, item));
};
// eslint-disable-next-line jsdoc/require-jsdoc
function isAsymmetric(obj) {
    return !!obj && typeof obj === "object" && "asymmetricMatch" in obj;
}
// You can use expect.Anything(), expect.ObjectContaining, etc in jest, this makes it nicer to read
// when we print error messages
// eslint-disable-next-line jsdoc/require-jsdoc
function jestAsymetricMatcherStringifyReplacer(_key, value) {
    return isAsymmetric(value) ? `expect.${value.toString()}` : value;
}
// eslint-disable-next-line jsdoc/require-jsdoc
function getAssertElementWithProperties(
// We have the evaluation function configurable so we can make use of the specific testing frameworks capabilities
// This makes the resulting tests more native to the testing framework
customPassEvaluation) {
    const passEvaluation = customPassEvaluation || defaultPassEvaluation;
    return function getAssertElementWithProperties(type, received, itemType, properties = {}) {
        let stack;
        // Rececived could either be a JSON string or a path to a file
        const stackContent = fs.existsSync(received)
            ? fs.readFileSync(received, "utf8")
            : received;
        try {
            stack = JSON.parse(stackContent);
        }
        catch (e) {
            throw new Error(`invalid JSON string passed: ${stackContent}`);
        }
        const items = Object.values(Object.entries(stack[type] || {}) // for all data/resource entries
            .find(
        // find the object with a matching name
        ([type, _values]) => type === itemType.tfResourceType)?.[1] || {} // get all items of that type (encoded as a record of name -> config)
        ) || []; // get a list of all configs of that type
        const pass = passEvaluation(items, properties);
        if (pass) {
            return new AssertionReturn(`Expected no ${itemType.tfResourceType} with properties ${JSON.stringify(properties, jestAsymetricMatcherStringifyReplacer)} to be present in synthesized stack.
Found ${items.length === 0 ? "no" : items.length} ${itemType.tfResourceType} resources instead${items.length > 0 ? ":\n" + JSON.stringify(items, null, 2) : ""}`, pass);
        }
        else {
            return new AssertionReturn(`Expected ${itemType.tfResourceType} with properties ${JSON.stringify(properties, jestAsymetricMatcherStringifyReplacer)} to be present in synthesized stack.
Found ${items.length === 0 ? "no" : items.length} ${itemType.tfResourceType} resources instead${items.length > 0 ? ":\n" + JSON.stringify(items, null, 2) : ""}`, pass);
        }
    };
}
/**
 * Returns the function toHaveDataSourceWithProperties using the evaluation properties of customPassEvaluation
 * @param customPassEvaluation
 * @returns {getToHaveDataSourceWithProperties~toHaveDataSourceWithProperties}
 */
function getToHaveDataSourceWithProperties(customPassEvaluation) {
    /**
     * Evaluates the received stack to have the data source resourceType containing specified properties
     * @param received
     * @param resourceType
     * @param properties
     * @returns {AssertionReturn}
     */
    return function toHaveDataSourceWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("data", received, resourceType, properties);
    };
}
exports.getToHaveDataSourceWithProperties = getToHaveDataSourceWithProperties;
/**
 * Returns the function toHaveResourceWithProperties using the evaluation properties of customPassEvaluation
 * @param customPassEvaluation
 * @returns
 */
function getToHaveResourceWithProperties(customPassEvaluation) {
    /**
     * Evaluates the received stack to have the resource resourceType containing specified properties
     * @param received
     * @param resourceType
     * @param properties
     * @returns {AssertionReturn}
     */
    return function toHaveResourceWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("resource", received, resourceType, properties);
    };
}
exports.getToHaveResourceWithProperties = getToHaveResourceWithProperties;
/**
 * A helper util to verify wether an Error was caused by the Nodejs `process.spawn` API.
 *
 * @param   {Error}   err The Error object to verify
 * @returns {Boolean}     A bool indicating wether the input Error is containing process.spawn output.
 */
const isExecSpawnError = (err) => "output" in err &&
    Array.isArray(err.output) &&
    err.output.some((buf) => Buffer.isBuffer(buf));
/**
 * A helper util to append `process.spawn` output to assertion messages to improve developer expirience.
 *
 * @param   {String} message The message to optionally append process output to.
 * @param   {Error}  err     The error from which the `process.spawn` output should be retreived from.
 * @returns {String}         The finalized assertion message decorated with the `process.spawn` output.
 */
const withProcessOutput = (message, err) => {
    let output = "";
    if (isExecSpawnError(err)) {
        output =
            err.output
                ?.map((buffer) => buffer?.toString("utf8"))
                .filter(Boolean)
                .join("\n") ?? "";
    }
    const appendix = output.length ? `. Output: ${output}` : "";
    return `${message}: ${err}${appendix}.`;
};
/**
 * Returns the function toHaveProviderWithProperties using the evaluation properties of customPassEvaluation
 * @param customPassEvaluation
 * @returns {getToHaveProviderWithProperties~toHaveProviderWithProperties}
 */
function getToHaveProviderWithProperties(customPassEvaluation) {
    /**
     * Evaluates the received stack to have the provider resourceType containing specified properties
     * @param received
     * @param resourceType
     * @param properties
     * @returns {AssertionReturn}
     */
    return function toHaveProviderWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("provider", received, resourceType, properties);
    };
}
exports.getToHaveProviderWithProperties = getToHaveProviderWithProperties;
/**
 * Evaluates the validity of the received stack
 * @param received
 * @returns {AssertionReturn}
 */
function toBeValidTerraform(received) {
    try {
        if (!fs.statSync(received).isDirectory()) {
            throw new Error("Path is not a directory");
        }
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a terraform directory: ${e}`, false);
    }
    try {
        const manifest = JSON.parse(fs.readFileSync(path.resolve(received, "manifest.json"), "utf8"));
        const stacks = Object.entries(manifest.stacks);
        stacks.forEach(([name, stack]) => {
            const opts = {
                cwd: path.resolve(received, stack.workingDirectory),
                env: process.env,
                stdio: "pipe",
            };
            (0, child_process_1.execSync)(`${util_1.terraformBinaryName} init`, opts);
            const out = (0, child_process_1.execSync)(`${util_1.terraformBinaryName} validate -json`, opts);
            const result = JSON.parse(out.toString());
            if (!result.valid) {
                throw new Error(`Found ${result.error_count} Errors in stack ${name}: ${result.diagnostics.join("\n")}`);
            }
        });
        return new AssertionReturn(`Expected subject not to be a valid terraform stack`, true);
    }
    catch (e) {
        return new AssertionReturn(withProcessOutput(`Expected subject to be a valid terraform stack`, e), false);
    }
}
exports.toBeValidTerraform = toBeValidTerraform;
/**
 * Evaluates the ability for the received stack to successfully plan
 * @param received
 * @returns {AssertionReturn}
 */
function toPlanSuccessfully(received) {
    try {
        if (!fs.statSync(received).isDirectory()) {
            throw new Error("Path is not a directory");
        }
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a terraform directory: ${e}`, false);
    }
    try {
        const manifest = JSON.parse(fs.readFileSync(path.resolve(received, "manifest.json"), "utf8"));
        const stacks = Object.entries(manifest.stacks);
        stacks.forEach(([, stack]) => {
            const opts = {
                cwd: path.resolve(received, stack.workingDirectory),
                env: process.env,
                stdio: "ignore",
            };
            (0, child_process_1.execSync)(`${util_1.terraformBinaryName} init`, opts);
            // Throws on a non-zero exit code
            (0, child_process_1.execSync)(`${util_1.terraformBinaryName} plan -input=false -lock=false `, opts);
        });
        return new AssertionReturn(`Expected subject not to plan successfully`, true);
    }
    catch (e) {
        return new AssertionReturn(withProcessOutput(`Expected subject to plan successfully`, e), false);
    }
}
exports.toPlanSuccessfully = toPlanSuccessfully;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0Y2hlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtYXRjaGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixpREFBMkQ7QUFDM0Qsa0NBQXlEO0FBYXpEOztHQUVHO0FBQ0gsTUFBYSxlQUFlO0lBQzFCOzs7O09BSUc7SUFDSCxZQUE0QixPQUFlLEVBQWtCLElBQWE7UUFBOUMsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFrQixTQUFJLEdBQUosSUFBSSxDQUFTO0lBQUcsQ0FBQzs7OztBQU5uRSwwQ0FBZTtBQVc1Qjs7OztHQUlHO0FBQ0gsU0FBZ0IsbUJBQW1CLENBQ2pDLFFBQXlCO0lBRXpCLE9BQU87UUFDTCxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU87UUFDL0IsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJO0tBQ3BCLENBQUM7QUFDSixDQUFDO0FBUEQsa0RBT0M7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixzQ0FBc0MsQ0FDcEQsUUFBaUIsRUFDakIsUUFBaUI7SUFFakIsUUFBUSxPQUFPLFFBQVEsRUFBRTtRQUN2QixLQUFLLFFBQVE7WUFDWCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzNCLE9BQU8sQ0FDTCxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztvQkFDdkIsUUFBUSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTTtvQkFDbkMsUUFBUSxDQUFDLEtBQUssQ0FDWixDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUNkLHNDQUFzQyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyw2QkFBNkI7cUJBQzlGLENBQ0YsQ0FBQzthQUNIO1lBQ0QsSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEs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LGlDQUFpQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFFLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLGVBQWUsQ0FDeEIsMkNBQTJDLEVBQzNDLElBQUksQ0FDTCxDQUFDO0tBQ0g7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE9BQU8sSUFBSSxlQUFlLENBQ3hCLGlCQUFpQixDQUFDLHVDQUF1QyxFQUFFLENBQUMsQ0FBQyxFQUM3RCxLQUFLLENBQ04sQ0FBQztLQUNIO0FBQ0gsQ0FBQztBQXpDRCxnREF5Q0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBleGVjU3luYywgU3Bhd25TeW5jUmV0dXJucyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgeyBzbmFrZUNhc2UsIHRlcnJhZm9ybUJpbmFyeU5hbWUgfSBmcm9tIFwiLi4vdXRpbFwiO1xuXG4vLyBUZXJyYWZvcm1Db25zdHJ1Y3RvciBpcyBjbGFzcyB3aXRoIHRoZSBzdGF0aWMgcHJvcGVydHkgJ3RmUmVzb3VyY2VUeXBlJ1xuZXhwb3J0IGludGVyZmFjZSBUZXJyYWZvcm1Db25zdHJ1Y3RvciB7XG4gIHJlYWRvbmx5IHRmUmVzb3VyY2VUeXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFN5bnRoZXNpemVkU3RhY2sgPSB7XG4gIHJlc291cmNlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBwcm92aWRlcjogUmVjb3JkPHN0cmluZywgYW55Pjtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50cyBvZiBhIHJldHVybiBieSBhbiBhc3NlcnRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEFzc2VydGlvblJldHVybiB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQXNzZXJ0aW9uUmV0dXJuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gU3RyaW5nIG1lc3NhZ2UgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVzdWx0IG9mIHRoZSBhc3NlcnRpb25cbiAgICogQHBhcmFtIHBhc3MgLSBCb29sZWFuIHBhc3MgZGVub3RpbmcgdGhlIHN1Y2Nlc3Mgb2YgdGhlIGFzc2VydGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZywgcHVibGljIHJlYWRvbmx5IHBhc3M6IGJvb2xlYW4pIHt9XG59XG5cbmV4cG9ydCB0eXBlIE1hdGNoZXJSZXR1cm5KZXN0ID0geyBtZXNzYWdlOiAoKSA9PiBzdHJpbmc7IHBhc3M6IGJvb2xlYW4gfTtcblxuLyoqXG4gKiBSZWZvcm1hdHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBiYXNlIHRlc3RpbmcgbWF0Y2hlciByZXR1cm4gdHlwZSBBc3NlcnRpb25SZXR1cm4gaW50byB0eXBlIHVzZWFibGUgYnkgamVzdFxuICogQHBhcmFtIHRvUmV0dXJuXG4gKiBAcmV0dXJucyB7TWF0Y2hlclJldHVybkplc3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5NYXRjaGVyVG9KZXN0KFxuICB0b1JldHVybjogQXNzZXJ0aW9uUmV0dXJuXG4pOiBNYXRjaGVyUmV0dXJuSmVzdCB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogKCkgPT4gdG9SZXR1cm4ubWVzc2FnZSxcbiAgICBwYXNzOiB0b1JldHVybi5wYXNzLFxuICB9O1xufVxuXG4vKipcbiAqIENvbXBhcmVzIGV4cGVjdGVkIGFuZCByZWNlaXZlZC4gQWxsIGV4cGVjdGVkIHByb3BlcnRpZXMgYXJlIG1hdGNoZWQgYW5kIGNvbnNpZGVyZWQgZXF1YWwgZXZlbiBpZlxuICogdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcyBpbiB0aGUgcmVjZWl2ZWQgb2JqZWN0IHRoYW4gaW4gdGhlIGV4cGVjdGVkIG9iamVjdCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgc3RpbGwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0gZXhwZWN0ZWRcbiAqIEBwYXJhbSByZWNlaXZlZFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3ltZXRyaWNEZWVwRXF1YWxJZ25vcmluZ09iamVjdENhc2luZyhcbiAgZXhwZWN0ZWQ6IHVua25vd24sXG4gIHJlY2VpdmVkOiB1bmtub3duXG4pOiBib29sZWFuIHtcbiAgc3dpdGNoICh0eXBlb2YgZXhwZWN0ZWQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHJlY2VpdmVkKSAmJlxuICAgICAgICAgIGV4cGVjdGVkLmxlbmd0aCA9PT0gcmVjZWl2ZWQubGVuZ3RoICYmXG4gICAgICAgICAgZXhwZWN0ZWQuZXZlcnkoXG4gICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+XG4gICAgICAgICAgICAgIGFzeW1ldHJpY0RlZXBFcXVhbElnbm9yaW5nT2JqZWN0Q2FzaW5nKGl0ZW0sIHJlY2VpdmVkW2luZGV4XSkgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwgJiYgcmVjZWl2ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCAmJiByZWNlaXZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdGVkID09PSBudWxsIHx8IHJlY2VpdmVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhbGxvdyBzbmFrZSBjYXNlIGFzIHdlbGwgYXMgY2FtZWwgY2FzZVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGV4cGVjdGVkIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICAgIGlmICgocmVjZWl2ZWQgYXMgYW55KVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoXG4gICAgICAgICAgICAoZXhwZWN0ZWQgYXMgYW55KVtrZXldLFxuICAgICAgICAgICAgKHJlY2VpdmVkIGFzIGFueSlba2V5XVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHJlY2VpdmVkIGFzIGFueSlbc25ha2VDYXNlKGtleSldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoXG4gICAgICAgICAgICAoZXhwZWN0ZWQgYXMgYW55KVtrZXldLFxuICAgICAgICAgICAgKHJlY2VpdmVkIGFzIGFueSlbc25ha2VDYXNlKGtleSldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHJlY2VpdmVkO1xuICB9XG59XG5jb25zdCBkZWZhdWx0UGFzc0V2YWx1YXRpb24gPSAoXG4gIGl0ZW1zOiBhbnksXG4gIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuKSA9PiB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGl0ZW1zKS5zb21lKChpdGVtOiBhbnkpID0+XG4gICAgYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoYXNzZXJ0ZWRQcm9wZXJ0aWVzLCBpdGVtKVxuICApO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIGlzQXN5bW1ldHJpYyhvYmo6IGFueSkge1xuICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBcImFzeW1tZXRyaWNNYXRjaFwiIGluIG9iajtcbn1cbi8vIFlvdSBjYW4gdXNlIGV4cGVjdC5Bbnl0aGluZygpLCBleHBlY3QuT2JqZWN0Q29udGFpbmluZywgZXRjIGluIGplc3QsIHRoaXMgbWFrZXMgaXQgbmljZXIgdG8gcmVhZFxuLy8gd2hlbiB3ZSBwcmludCBlcnJvciBtZXNzYWdlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIGplc3RBc3ltZXRyaWNNYXRjaGVyU3RyaW5naWZ5UmVwbGFjZXIoX2tleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gIHJldHVybiBpc0FzeW1tZXRyaWModmFsdWUpID8gYGV4cGVjdC4ke3ZhbHVlLnRvU3RyaW5nKCl9YCA6IHZhbHVlO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmZ1bmN0aW9uIGdldEFzc2VydEVsZW1lbnRXaXRoUHJvcGVydGllcyhcbiAgLy8gV2UgaGF2ZSB0aGUgZXZhbHVhdGlvbiBmdW5jdGlvbiBjb25maWd1cmFibGUgc28gd2UgY2FuIG1ha2UgdXNlIG9mIHRoZSBzcGVjaWZpYyB0ZXN0aW5nIGZyYW1ld29ya3MgY2FwYWJpbGl0aWVzXG4gIC8vIFRoaXMgbWFrZXMgdGhlIHJlc3VsdGluZyB0ZXN0cyBtb3JlIG5hdGl2ZSB0byB0aGUgdGVzdGluZyBmcmFtZXdvcmtcbiAgY3VzdG9tUGFzc0V2YWx1YXRpb24/OiAoXG4gICAgaXRlbXM6IGFueVtdLCAvLyBjb25maWd1cmF0aW9ucyBvZiB0aGUgcmVxdWVzdGVkIHR5cGVcbiAgICBhc3NlcnRlZFByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKSA9PiBib29sZWFuXG4pIHtcbiAgY29uc3QgcGFzc0V2YWx1YXRpb24gPSBjdXN0b21QYXNzRXZhbHVhdGlvbiB8fCBkZWZhdWx0UGFzc0V2YWx1YXRpb247XG4gIHJldHVybiBmdW5jdGlvbiBnZXRBc3NlcnRFbGVtZW50V2l0aFByb3BlcnRpZXMoXG4gICAgdHlwZToga2V5b2YgU3ludGhlc2l6ZWRTdGFjayxcbiAgICByZWNlaXZlZDogc3RyaW5nLFxuICAgIGl0ZW1UeXBlOiBUZXJyYWZvcm1Db25zdHJ1Y3RvcixcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgKTogQXNzZXJ0aW9uUmV0dXJuIHtcbiAgICBsZXQgc3RhY2s6IFN5bnRoZXNpemVkU3RhY2s7XG5cbiAgICAvLyBSZWNlY2l2ZWQgY291bGQgZWl0aGVyIGJlIGEgSlNPTiBzdHJpbmcgb3IgYSBwYXRoIHRvIGEgZmlsZVxuICAgIGNvbnN0IHN0YWNrQ29udGVudCA9IGZzLmV4aXN0c1N5bmMocmVjZWl2ZWQpXG4gICAgICA/IGZzLnJlYWRGaWxlU3luYyhyZWNlaXZlZCwgXCJ1dGY4XCIpXG4gICAgICA6IHJlY2VpdmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YWNrID0gSlNPTi5wYXJzZShzdGFja0NvbnRlbnQpIGFzIFN5bnRoZXNpemVkU3RhY2s7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIEpTT04gc3RyaW5nIHBhc3NlZDogJHtzdGFja0NvbnRlbnR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPVxuICAgICAgT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RhY2tbdHlwZV0gfHwge30pIC8vIGZvciBhbGwgZGF0YS9yZXNvdXJjZSBlbnRyaWVzXG4gICAgICAgICAgLmZpbmQoXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBvYmplY3Qgd2l0aCBhIG1hdGNoaW5nIG5hbWVcbiAgICAgICAgICAgIChbdHlwZSwgX3ZhbHVlc10pID0+IHR5cGUgPT09IGl0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlXG4gICAgICAgICAgKT8uWzFdIHx8IHt9IC8vIGdldCBhbGwgaXRlbXMgb2YgdGhhdCB0eXBlIChlbmNvZGVkIGFzIGEgcmVjb3JkIG9mIG5hbWUgLT4gY29uZmlnKVxuICAgICAgKSB8fCBbXTsgLy8gZ2V0IGEgbGlzdCBvZiBhbGwgY29uZmlncyBvZiB0aGF0IHR5cGVcbiAgICBjb25zdCBwYXNzID0gcGFzc0V2YWx1YXRpb24oaXRlbXMsIHByb3BlcnRpZXMpO1xuICAgIGlmIChwYXNzKSB7XG4gICAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgICAgYEV4cGVjdGVkIG5vICR7XG4gICAgICAgICAgaXRlbVR5cGUudGZSZXNvdXJjZVR5cGVcbiAgICAgICAgfSB3aXRoIHByb3BlcnRpZXMgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIGplc3RBc3ltZXRyaWNNYXRjaGVyU3RyaW5naWZ5UmVwbGFjZXJcbiAgICAgICAgKX0gdG8gYmUgcHJlc2VudCBpbiBzeW50aGVzaXplZCBzdGFjay5cbkZvdW5kICR7aXRlbXMubGVuZ3RoID09PSAwID8gXCJub1wiIDogaXRlbXMubGVuZ3RofSAke1xuICAgICAgICAgIGl0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlXG4gICAgICAgIH0gcmVzb3VyY2VzIGluc3RlYWQke1xuICAgICAgICAgIGl0ZW1zLmxlbmd0aCA+IDAgPyBcIjpcXG5cIiArIEpTT04uc3RyaW5naWZ5KGl0ZW1zLCBudWxsLCAyKSA6IFwiXCJcbiAgICAgICAgfWAsXG4gICAgICAgIHBhc3NcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgICBgRXhwZWN0ZWQgJHtpdGVtVHlwZS50ZlJlc291cmNlVHlwZX0gd2l0aCBwcm9wZXJ0aWVzICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBqZXN0QXN5bWV0cmljTWF0Y2hlclN0cmluZ2lmeVJlcGxhY2VyXG4gICAgICAgICl9IHRvIGJlIHByZXNlbnQgaW4gc3ludGhlc2l6ZWQgc3RhY2suXG5Gb3VuZCAke2l0ZW1zLmxlbmd0aCA9PT0gMCA/IFwibm9cIiA6IGl0ZW1zLmxlbmd0aH0gJHtcbiAgICAgICAgICBpdGVtVHlwZS50ZlJlc291cmNlVHlwZVxuICAgICAgICB9IHJlc291cmNlcyBpbnN0ZWFkJHtcbiAgICAgICAgICBpdGVtcy5sZW5ndGggPiAwID8gXCI6XFxuXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtcywgbnVsbCwgMikgOiBcIlwiXG4gICAgICAgIH1gLFxuICAgICAgICBwYXNzXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiB0b0hhdmVEYXRhU291cmNlV2l0aFByb3BlcnRpZXMgdXNpbmcgdGhlIGV2YWx1YXRpb24gcHJvcGVydGllcyBvZiBjdXN0b21QYXNzRXZhbHVhdGlvblxuICogQHBhcmFtIGN1c3RvbVBhc3NFdmFsdWF0aW9uXG4gKiBAcmV0dXJucyB7Z2V0VG9IYXZlRGF0YVNvdXJjZVdpdGhQcm9wZXJ0aWVzfnRvSGF2ZURhdGFTb3VyY2VXaXRoUHJvcGVydGllc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvSGF2ZURhdGFTb3VyY2VXaXRoUHJvcGVydGllcyhcbiAgY3VzdG9tUGFzc0V2YWx1YXRpb24/OiAoXG4gICAgaXRlbXM6IGFueSxcbiAgICBhc3NlcnRlZFByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKSA9PiBib29sZWFuXG4pIHtcbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgcmVjZWl2ZWQgc3RhY2sgdG8gaGF2ZSB0aGUgZGF0YSBzb3VyY2UgcmVzb3VyY2VUeXBlIGNvbnRhaW5pbmcgc3BlY2lmaWVkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHJlY2VpdmVkXG4gICAqIEBwYXJhbSByZXNvdXJjZVR5cGVcbiAgICogQHBhcmFtIHByb3BlcnRpZXNcbiAgICogQHJldHVybnMge0Fzc2VydGlvblJldHVybn1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0hhdmVEYXRhU291cmNlV2l0aFByb3BlcnRpZXMoXG4gICAgcmVjZWl2ZWQ6IHN0cmluZyxcbiAgICByZXNvdXJjZVR5cGU6IFRlcnJhZm9ybUNvbnN0cnVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICApOiBBc3NlcnRpb25SZXR1cm4ge1xuICAgIHJldHVybiBnZXRBc3NlcnRFbGVtZW50V2l0aFByb3BlcnRpZXMoY3VzdG9tUGFzc0V2YWx1YXRpb24pKFxuICAgICAgXCJkYXRhXCIsXG4gICAgICByZWNlaXZlZCxcbiAgICAgIHJlc291cmNlVHlwZSxcbiAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvSGF2ZVJlc291cmNlV2l0aFByb3BlcnRpZXMgdXNpbmcgdGhlIGV2YWx1YXRpb24gcHJvcGVydGllcyBvZiBjdXN0b21QYXNzRXZhbHVhdGlvblxuICogQHBhcmFtIGN1c3RvbVBhc3NFdmFsdWF0aW9uXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9IYXZlUmVzb3VyY2VXaXRoUHJvcGVydGllcyhcbiAgY3VzdG9tUGFzc0V2YWx1YXRpb24/OiAoXG4gICAgaXRlbXM6IGFueSxcbiAgICBhc3NlcnRlZFByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKSA9PiBib29sZWFuXG4pIHtcbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgcmVjZWl2ZWQgc3RhY2sgdG8gaGF2ZSB0aGUgcmVzb3VyY2UgcmVzb3VyY2VUeXBlIGNvbnRhaW5pbmcgc3BlY2lmaWVkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHJlY2VpdmVkXG4gICAqIEBwYXJhbSByZXNvdXJjZVR5cGVcbiAgICogQHBhcmFtIHByb3BlcnRpZXNcbiAgICogQHJldHVybnMge0Fzc2VydGlvblJldHVybn1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0hhdmVSZXNvdXJjZVdpdGhQcm9wZXJ0aWVzKFxuICAgIHJlY2VpdmVkOiBzdHJpbmcsXG4gICAgcmVzb3VyY2VUeXBlOiBUZXJyYWZvcm1Db25zdHJ1Y3RvcixcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgKTogQXNzZXJ0aW9uUmV0dXJuIHtcbiAgICByZXR1cm4gZ2V0QXNzZXJ0RWxlbWVudFdpdGhQcm9wZXJ0aWVzKGN1c3RvbVBhc3NFdmFsdWF0aW9uKShcbiAgICAgIFwicmVzb3VyY2VcIixcbiAgICAgIHJlY2VpdmVkLFxuICAgICAgcmVzb3VyY2VUeXBlLFxuICAgICAgcHJvcGVydGllc1xuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQSBoZWxwZXIgdXRpbCB0byB2ZXJpZnkgd2V0aGVyIGFuIEVycm9yIHdhcyBjYXVzZWQgYnkgdGhlIE5vZGVqcyBgcHJvY2Vzcy5zcGF3bmAgQVBJLlxuICpcbiAqIEBwYXJhbSAgIHtFcnJvcn0gICBlcnIgVGhlIEVycm9yIG9iamVjdCB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIHtCb29sZWFufSAgICAgQSBib29sIGluZGljYXRpbmcgd2V0aGVyIHRoZSBpbnB1dCBFcnJvciBpcyBjb250YWluaW5nIHByb2Nlc3Muc3Bhd24gb3V0cHV0LlxuICovXG5jb25zdCBpc0V4ZWNTcGF3bkVycm9yID0gKGVycjogYW55KTogZXJyIGlzIEVycm9yICYgU3Bhd25TeW5jUmV0dXJuczxhbnk+ID0+XG4gIFwib3V0cHV0XCIgaW4gZXJyICYmXG4gIEFycmF5LmlzQXJyYXkoZXJyLm91dHB1dCkgJiZcbiAgZXJyLm91dHB1dC5zb21lKChidWY6IGFueSkgPT4gQnVmZmVyLmlzQnVmZmVyKGJ1ZikpO1xuXG4vKipcbiAqIEEgaGVscGVyIHV0aWwgdG8gYXBwZW5kIGBwcm9jZXNzLnNwYXduYCBvdXRwdXQgdG8gYXNzZXJ0aW9uIG1lc3NhZ2VzIHRvIGltcHJvdmUgZGV2ZWxvcGVyIGV4cGlyaWVuY2UuXG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBvcHRpb25hbGx5IGFwcGVuZCBwcm9jZXNzIG91dHB1dCB0by5cbiAqIEBwYXJhbSAgIHtFcnJvcn0gIGVyciAgICAgVGhlIGVycm9yIGZyb20gd2hpY2ggdGhlIGBwcm9jZXNzLnNwYXduYCBvdXRwdXQgc2hvdWxkIGJlIHJldHJlaXZlZCBmcm9tLlxuICogQHJldHVybnMge1N0cmluZ30gICAgICAgICBUaGUgZmluYWxpemVkIGFzc2VydGlvbiBtZXNzYWdlIGRlY29yYXRlZCB3aXRoIHRoZSBgcHJvY2Vzcy5zcGF3bmAgb3V0cHV0LlxuICovXG5jb25zdCB3aXRoUHJvY2Vzc091dHB1dCA9IChtZXNzYWdlOiBzdHJpbmcsIGVycjogdW5rbm93bikgPT4ge1xuICBsZXQgb3V0cHV0ID0gXCJcIjtcblxuICBpZiAoaXNFeGVjU3Bhd25FcnJvcihlcnIpKSB7XG4gICAgb3V0cHV0ID1cbiAgICAgIGVyci5vdXRwdXRcbiAgICAgICAgPy5tYXAoKGJ1ZmZlcjogQnVmZmVyKSA9PiBidWZmZXI/LnRvU3RyaW5nKFwidXRmOFwiKSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIlxcblwiKSA/PyBcIlwiO1xuICB9XG5cbiAgY29uc3QgYXBwZW5kaXggPSBvdXRwdXQubGVuZ3RoID8gYC4gT3V0cHV0OiAke291dHB1dH1gIDogXCJcIjtcblxuICByZXR1cm4gYCR7bWVzc2FnZX06ICR7ZXJyfSR7YXBwZW5kaXh9LmA7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvSGF2ZVByb3ZpZGVyV2l0aFByb3BlcnRpZXMgdXNpbmcgdGhlIGV2YWx1YXRpb24gcHJvcGVydGllcyBvZiBjdXN0b21QYXNzRXZhbHVhdGlvblxuICogQHBhcmFtIGN1c3RvbVBhc3NFdmFsdWF0aW9uXG4gKiBAcmV0dXJucyB7Z2V0VG9IYXZlUHJvdmlkZXJXaXRoUHJvcGVydGllc350b0hhdmVQcm92aWRlcldpdGhQcm9wZXJ0aWVzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9IYXZlUHJvdmlkZXJXaXRoUHJvcGVydGllcyhcbiAgY3VzdG9tUGFzc0V2YWx1YXRpb24/OiAoXG4gICAgaXRlbXM6IGFueSxcbiAgICBhc3NlcnRlZFByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKSA9PiBib29sZWFuXG4pIHtcbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgcmVjZWl2ZWQgc3RhY2sgdG8gaGF2ZSB0aGUgcHJvdmlkZXIgcmVzb3VyY2VUeXBlIGNvbnRhaW5pbmcgc3BlY2lmaWVkIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHJlY2VpdmVkXG4gICAqIEBwYXJhbSByZXNvdXJjZVR5cGVcbiAgICogQHBhcmFtIHByb3BlcnRpZXNcbiAgICogQHJldHVybnMge0Fzc2VydGlvblJldHVybn1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiB0b0hhdmVQcm92aWRlcldpdGhQcm9wZXJ0aWVzKFxuICAgIHJlY2VpdmVkOiBzdHJpbmcsXG4gICAgcmVzb3VyY2VUeXBlOiBUZXJyYWZvcm1Db25zdHJ1Y3RvcixcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgKTogQXNzZXJ0aW9uUmV0dXJuIHtcbiAgICByZXR1cm4gZ2V0QXNzZXJ0RWxlbWVudFdpdGhQcm9wZXJ0aWVzKGN1c3RvbVBhc3NFdmFsdWF0aW9uKShcbiAgICAgIFwicHJvdmlkZXJcIixcbiAgICAgIHJlY2VpdmVkLFxuICAgICAgcmVzb3VyY2VUeXBlLFxuICAgICAgcHJvcGVydGllc1xuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSB2YWxpZGl0eSBvZiB0aGUgcmVjZWl2ZWQgc3RhY2tcbiAqIEBwYXJhbSByZWNlaXZlZFxuICogQHJldHVybnMge0Fzc2VydGlvblJldHVybn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVWYWxpZFRlcnJhZm9ybShyZWNlaXZlZDogc3RyaW5nKTogQXNzZXJ0aW9uUmV0dXJuIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWZzLnN0YXRTeW5jKHJlY2VpdmVkKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgIGBFeHBlY3RlZCBzdWJqZWN0IHRvIGJlIGEgdGVycmFmb3JtIGRpcmVjdG9yeTogJHtlfWAsXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gSlNPTi5wYXJzZShcbiAgICAgIGZzLnJlYWRGaWxlU3luYyhwYXRoLnJlc29sdmUocmVjZWl2ZWQsIFwibWFuaWZlc3QuanNvblwiKSwgXCJ1dGY4XCIpXG4gICAgKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IE9iamVjdC5lbnRyaWVzKG1hbmlmZXN0LnN0YWNrcyk7XG5cbiAgICBzdGFja3MuZm9yRWFjaCgoW25hbWUsIHN0YWNrXSkgPT4ge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgY3dkOiBwYXRoLnJlc29sdmUocmVjZWl2ZWQsIChzdGFjayBhcyBhbnkpLndvcmtpbmdEaXJlY3RvcnkpLFxuICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICB9IGFzIGFueTtcbiAgICAgIGV4ZWNTeW5jKGAke3RlcnJhZm9ybUJpbmFyeU5hbWV9IGluaXRgLCBvcHRzKTtcbiAgICAgIGNvbnN0IG91dCA9IGV4ZWNTeW5jKGAke3RlcnJhZm9ybUJpbmFyeU5hbWV9IHZhbGlkYXRlIC1qc29uYCwgb3B0cyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0LnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGb3VuZCAke1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yX2NvdW50XG4gICAgICAgICAgfSBFcnJvcnMgaW4gc3RhY2sgJHtuYW1lfTogJHtyZXN1bHQuZGlhZ25vc3RpY3Muam9pbihcIlxcblwiKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICBgRXhwZWN0ZWQgc3ViamVjdCBub3QgdG8gYmUgYSB2YWxpZCB0ZXJyYWZvcm0gc3RhY2tgLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgIHdpdGhQcm9jZXNzT3V0cHV0KGBFeHBlY3RlZCBzdWJqZWN0IHRvIGJlIGEgdmFsaWQgdGVycmFmb3JtIHN0YWNrYCwgZSksXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGFiaWxpdHkgZm9yIHRoZSByZWNlaXZlZCBzdGFjayB0byBzdWNjZXNzZnVsbHkgcGxhblxuICogQHBhcmFtIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7QXNzZXJ0aW9uUmV0dXJufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QbGFuU3VjY2Vzc2Z1bGx5KHJlY2VpdmVkOiBzdHJpbmcpOiBBc3NlcnRpb25SZXR1cm4ge1xuICB0cnkge1xuICAgIGlmICghZnMuc3RhdFN5bmMocmVjZWl2ZWQpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgYEV4cGVjdGVkIHN1YmplY3QgdG8gYmUgYSB0ZXJyYWZvcm0gZGlyZWN0b3J5OiAke2V9YCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKFxuICAgICAgZnMucmVhZEZpbGVTeW5jKHBhdGgucmVzb2x2ZShyZWNlaXZlZCwgXCJtYW5pZmVzdC5qc29uXCIpLCBcInV0ZjhcIilcbiAgICApO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gT2JqZWN0LmVudHJpZXMobWFuaWZlc3Quc3RhY2tzKTtcblxuICAgIHN0YWNrcy5mb3JFYWNoKChbLCBzdGFja10pID0+IHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGN3ZDogcGF0aC5yZXNvbHZlKHJlY2VpdmVkLCAoc3RhY2sgYXMgYW55KS53b3JraW5nRGlyZWN0b3J5KSxcbiAgICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgICAgc3RkaW86IFwiaWdub3JlXCIsXG4gICAgICB9IGFzIGFueTtcbiAgICAgIGV4ZWNTeW5jKGAke3RlcnJhZm9ybUJpbmFyeU5hbWV9IGluaXRgLCBvcHRzKTtcblxuICAgICAgLy8gVGhyb3dzIG9uIGEgbm9uLXplcm8gZXhpdCBjb2RlXG4gICAgICBleGVjU3luYyhgJHt0ZXJyYWZvcm1CaW5hcnlOYW1lfSBwbGFuIC1pbnB1dD1mYWxzZSAtbG9jaz1mYWxzZSBgLCBvcHRzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgYEV4cGVjdGVkIHN1YmplY3Qgbm90IHRvIHBsYW4gc3VjY2Vzc2Z1bGx5YCxcbiAgICAgIHRydWVcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICB3aXRoUHJvY2Vzc091dHB1dChgRXhwZWN0ZWQgc3ViamVjdCB0byBwbGFuIHN1Y2Nlc3NmdWxseWAsIGUpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG59XG4iXX0=